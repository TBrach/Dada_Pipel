---
title: "Generalized phyloseq analysis"
author: "Thorsten Brach"
date: "24/7/2017"
output: html_document
---

```{r, echo = FALSE, message=FALSE, include = FALSE}
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")

PackageVersions <- data.frame(R = version$version.string,
                              dada2 = packageVersion("dada2"),
                              vegan = packageVersion("vegan"),
                              ggplot2 = packageVersion("ggplot2"),
                              dplyr = packageVersion("dplyr"),
                              tidyr = packageVersion("tidyr"),
                              gridExtra = packageVersion("gridExtra"))
for (i in 1:ncol(PackageVersions)){PackageVersions[,i] <- as.character(PackageVersions[,i])}
PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version)

```

# Set Input data and load data

- parameters that should be defined here
    - prevalence in percent

```{r, echo = FALSE, message=FALSE}
# - filtering inputs -
prevalence <- 20 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --

# - rarefaction inputs -
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # IF NULL, min(sample_sums(ps)) is used!
rare_type <- "sample" # must be either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --

# - plot/statistics inputs -
taxa_are_rows = FALSE 
group_var <- "Group" # tha variable based on which samples will be grouped HAS TO BE SET IN samdf BELOW!!
group_var_levels <- c("Young", "MiddleAged", "Old") # the factor levels of the group_var in the order you want them in your plots
alpha_div_measures <- c("Observed", "Shannon")
# 

# - beta diversity -
dist_methods <- c("bray", "jsd", "jaccard") # c("unifrac", "wunifrac", "jsd", "bray", "jaccard", "euclidean")
#

# - file/path inputs -
datapath <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/16S_Sequencing/2017-07-13_DK_age_ManiAging/Dada2_Analysis"

# NB: taxonomy path should start in datapath
taxonomy.path <- "Dada_Taxonomy/Silva_v128/Taxonomy_Silva128_minBoot50_allowMT.RData"

functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# -- 


# -- Load all data in --
# laod seqtab.nochim
load(file.path(datapath, "Dada_Data/DenoisedData.RData"))

# load QualityStats
load(file.path(datapath, "Dada_Data/QualityStats.RData"))

# load Taxonomy
load(file.path(datapath, taxonomy.path))

# sanity checks if sample names fit
sample.names <- rownames(seqtab.nochim)
if (!all.equal(rownames(seqtab.nochim), names(F_QualityStats))) {
        stop("check sample names")
}
if (!all.equal(rownames(seqtab.nochim), as.character(ReadSummary$Sample))) {
        stop("check sample names")
}

# # check the size of the objects
# all_objects <- ls()
# object_memory <- vector(mode = "character", length = length(all_objects))
# for (i in 1:length(all_objects)) {
#         object_memory[i] <- object.size(get(all_objects[i]))
# }
# data.frame(all_objects, object_memory)
rm(mergers, seqtab, taxa)
# ---- 

# -- load all functions in --
source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
source(file.path(functionpath, "Dada_PlotFunctions.R"))
# ----
```

## Generate the data.frame holding the sample data of your study for phyloseq

- **NB: the generated samdf must be a data.frame in which rows are samples and columns different variables, the row/sample order must fit to seqtab.nochim, i.e. same rownames!**
- **NB: the variable you later group the samples with, e.g. for alpha diversity comparison, should be a factor with the levels in the order you like**
- NB3: file does not work without sample_data for your phyloseq object, so make up some if you do not have it

```{r, echo = FALSE, message = FALSE}
# generate the data frame with the sample data
sample.path <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/Results_RAnalysis"
load(file.path(sample.path, "ManiAging.RData"))

# I start with the quality report from the sequencing
samdf <- ManiAging[["QR"]]

# remove columns without information
samdf <- dplyr::select(samdf, -Tube.No., -TotalMass_mug, -Library.Type)

# adjust sample order in samdf to that of seqtab.nochim, and add rownames = rownames(seqtab.nochim)
samples.out <- rownames(seqtab.nochim)
Study <- sapply(strsplit(samples.out, "-"), `[`, 1)
IDfirst <- paste(sapply(strsplit(samples.out, "-"), `[`, 2))
IDsecond <- paste(sapply(strsplit(samples.out, "-"), `[`, 3))
IDorder <- vector(mode = "character", length = length(samples.out))
IDorder[IDsecond == "NA"] <- IDfirst[IDsecond == "NA"]
IDorder[IDsecond != "NA"] <- paste(IDfirst[IDsecond != "NA"], ".", IDsecond[IDsecond != "NA"], sep = "")

samdf <- samdf[match(IDorder, samdf$Mouse_ID),]

# add more columns/data collected for the samples: Example Hematology
Hematology <- ManiAging[["Hematology"]]
colnames(Hematology)[4:24] <- c("Leukocytes", "Erythrocytes", "Hemoglobin", "Hematocrit", "MCV", "MCHC", "Thrombocytes", "MPV", "MPC",
                                "PC_Neutrophils", "PC_Lymphocytes", "PC_Monocytes", "PC_Eosinophils", "PC_Basophils", "PC_LUC", "Neutrophils",
                                "Lymphocytes", "Monocytes", "Eosinophils", "Basophils", "LUC")
# add Lymphoid/Myeoloid Ratio CHECK
Hematology <- mutate(Hematology, Myeloid = Neutrophils + Monocytes + Eosinophils + Basophils + LUC, LymphoidToMyeloid = Lymphocytes/Myeloid)
Hematology <- select(Hematology, 1, 4:10,19:20, 25, 27) #remove also Group as it would be double

samdf <- merge(samdf, Hematology, by = "Mouse_ID", all.x = TRUE)

samdf$Group <- factor(samdf$Group, levels = group_var_levels, ordered = TRUE)
rownames(samdf) <- samples.out

# sanity check
if (!identical(samples.out, sample.names)) {
        stop("sample names in samdf do not fit to seqtab.nochim, check")
}

# Generate the phyloseq file
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows = taxa_are_rows), 
               sample_data(samdf), 
               tax_table(taxa.species))
ps


```


# Input parameters and package versions used

## DadaWrapper

```{r, echo = FALSE, message=FALSE}
InputDada <- data.frame(Argument = names(unlist(Input)), Value = unlist(Input))
rownames(InputDada) <- NULL
knitr::kable(PackageVersions)
knitr::kable(InputDada)
```

 
## Dada_WrapperAssignTaxonomyAddSpecies

```{r, echo = FALSE, message=FALSE}
InputSave <- InputSave[c("minBoot", "allowMultiple", "PathToRefs", "RefDataBase", "SepciesDB", "PathToSave", "tryRC")]
InputAssign <- data.frame(Argument = names(unlist(InputSave)), Value = unlist(InputSave))
rownames(InputAssign) <- NULL
knitr::kable(InputAssign)
```

## In this analysis

- Inputs and PackageVersions

```{r, echo = FALSE, message=FALSE}
# -- Store Inputs --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}

if (is.null(rare_max_total)){
        rare_max_total <- quantile(sample_sums(ps), probs = .25)
}

Inputs <- list(prevalence = prevalence,
               min_obs = min_obs,
               seed = seed,
               step_size = step_size,
               rare_level = rare_level,
               rare_type = rare_type,
               rare_max_total = rare_max_total,
               group_var = group_var,
               group_var_levels = group_var_levels,
               alpha_div_measures = alpha_div_measures,
               taxa_are_rows = taxa_are_rows,
               datapath = datapath,
               taxonomy.path = taxonomy.path,
               functionpath = functionpath)
# ----

InputAnalysis <- data.frame(Argument = names(unlist(Inputs)), Value = unlist(Inputs))
rownames(InputAnalysis) <- NULL
knitr::kable(InputAnalysis)
knitr::kable(PackageVersionsAnal)
```


# Plots illustrating the quality of the reads and the dada2 steps

```{r, echo = FALSE, message=FALSE}
Tr <- QS_Median_OverviewPlot(QStatsList = F_QualityStats, SampleNames = sample.names)
Tr <- Tr + 
        geom_vline(xintercept = Input$trimLeft[1], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[1], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: FW reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[1], sep = ""))

TrR <- QS_Median_OverviewPlot(QStatsList = R_QualityStats, SampleNames = sample.names)
TrR <- TrR + 
        geom_vline(xintercept = Input$trimLeft[2], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[2], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: RV reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[2], sep = ""))

```

```{r, fig.width = 8, fig.height = 8, warning = FALSE, message = FALSE}
grid.arrange(Tr, TrR, nrow = 2)
```


## Plot the error rates determined by dada2

```{r, echo = FALSE, message=FALSE}
Tr <- plotErrors(err_F, nominalQ = TRUE)
Tr <- Tr + ggtitle("err_F error rates")
TrR <- plotErrors(err_R, nominalQ = TRUE)
TrR <- TrR + ggtitle("err_R error rates")
```
```{r, fig.width = 14, fig.height = 14, warning = FALSE, message = FALSE}
grid.arrange(Tr, TrR, nrow = 2)
```


## plot the number of reads that survived the different dada2 steps

```{r, echo = FALSE, message=FALSE}
Tr <- NoReads_StepsSimple(ReadSummary = ReadSummary, SampleNames = sample.names, sort = TRUE)
Tr <- Tr + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10),
                 text = element_text(size=14))
```
```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE}
Tr
```


# Sample distribution of the `r ncol(seqtab.nochim)` found sequence variants (SVs)

```{r, echo = FALSE, message=FALSE}
df_ab_prev <- data.frame(SV_ID = 1:ncol(seqtab.nochim), abundance = colSums(seqtab.nochim), prevalence = colSums(seqtab.nochim != 0), sparsity = colSums(seqtab.nochim == 0), mean_abundance_nonzero = apply(seqtab.nochim, 2, function(x){mean(x[x > 0])}),
                         median_abundance_nonzero = apply(seqtab.nochim, 2, function(x){median(x[x > 0])}))

TrrList <- plot_correlations_abundance_prev_sparsity(df_ab_prev)
```

```{r, fig.width = 14, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrrList[[1]], TrrList[[2]], ncol = 2)
```

```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrrList[3:10], ncol = 2))
```


```{r, echo = FALSE, message=FALSE}
TrList <- plotSVdistributions(seqtab.nochim, prevalence = prevalence)
```

```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrList[1:4], nrow=4))
```


# Explore taxonomic assignment

- the assignment distribution including all found SVs:

```{r, echo = FALSE, message=FALSE}
assignment_distribution <- get_assignemnt_distribution(taxa.species)
knitr::kable(assignment_distribution)
```

- the Species that were assigned unambiguously:

```{r, echo = FALSE, message=FALSE}
# look at the species that have been assigned ambiguously
the_ambiguous_species <- unname(taxa.species[grep(pattern = "/", taxa.species[,'Species']), c('Genus', 'Species')])
colnames(the_ambiguous_species) <- c("Genus", "Species")
knitr::kable(as.data.frame(the_ambiguous_species))
```

## Is the taxonomic assignment better for more abundant/pevalent SVs?

- NB: abundance filters of taxa are based on total abundance over all samples (taxa_sums) without library size correction

```{r, echo = FALSE, message=FALSE}
assign_vs_ab <- check_assignment_vs_abundance(taxa.species, seqtab.nochim, abundanceQuantiles = seq(0, 95, by = 5))

assign_vs_prev <- check_assignment_vs_prevalence(taxa.species, seqtab.nochim, prevalences = seq(0, 95, by = 5))
```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(assign_vs_prev[[2]], assign_vs_ab[[2]], nrow = 2)
```

```{r, echo = FALSE, message=FALSE}
TrLists <- plotTaxLevelvsAbundPrev(taxa = taxa.species, seqtab = seqtab.nochim)
TrList_ab <- TrLists[["TrList_ab"]]
TrList_prev <- TrLists[["TrList_prev"]]
Last3Levels <- colnames(taxa.species)[(ncol(taxa.species)-2):ncol(taxa.species)]
TrList <- c(TrList_ab[Last3Levels], TrList_prev[Last3Levels])
rm(TrLists)
```

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList[[1]], TrList[[4]], TrList[[2]], TrList[[5]], TrList[[3]], TrList[[6]], ncol = 2)
```



# raw **alpha-diversity**, i.e. without correction for total amplicons (i.e. no rarifying)

## Construct phylogenetic tree



- NB: estimate_richness warns if no singletons are in the data, i.e. if !any(otu_table(ps) == 1) = TRUE (= !any(seqtab.nochim == 1))
    - dada2 seqtabs tend to be without singletons, most likely because low abundance SVs are considered errors from more abundant SVs

```{r, message = FALSE, warning = FALSE, echo = FALSE}
DF_alpha_list <- calculate_alphadiversity(physeq = ps, measures = alpha_div_measures)
DF_alpha <- DF_alpha_list[[1]]
DF_alpha_no_rare <- DF_alpha # just to save it for comparison later

alpha_div_measures2 <- alpha_div_measures
if ("Observed" %in% alpha_div_measures) {
        alpha_div_measures2[alpha_div_measures2 == "Observed"] <- "Richness" 
}

pairwise.tt_rich <- pairwise.t.test(x = DF_alpha$Richness, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
# compare, to get the same results as individual t.test you need pool.sd = F
# t.test(x = DF_alpha$Richness[DF_alpha$Group == "Old"], y = DF_alpha$Richness[DF_alpha$Group == "MiddleAged"], alternative = "two", var.equal = F)$p.value

pairwise.tt_shannon <- pairwise.t.test(x = DF_alpha$Shannon, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

pairwise.tt_total <- pairwise.t.test(x = DF_alpha$Total, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

pairwise.tt_rich_resids <- pairwise.t.test(x = DF_alpha$Richness_resids, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

pairwise.tt_shannon_resids <- pairwise.t.test(x = DF_alpha$Shannon_resids, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

# TrListBP <- plotAlphaDiversity(ps, x = group_var, color = group_var, group = group_var, measures = c("Observed", "Shannon"))
TrListBP <- boxplot_alphaDiv_fromDF(DF = DF_alpha, color = group_var, group = group_var, measures = c(alpha_div_measures2, paste(alpha_div_measures2, "resids", sep = "_")))

# TrList_lm <- plot_alphaDivVstotalAmplicons(physeq = ps, measures = alpha_div_measures, color = group_var)
TrList_lm <- plot_alphaDivVstotalAmplicons_fromList(DF_List = DF_alpha_list, measures = alpha_div_measures2, color = group_var)
```

```{r, fig.width = 14, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]], ncol = 2)
```

- p.values for Richness

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_rich$p.value)
```

- p.values for Shannon

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_shannon$p.value)
```


### Illustrate possible influence of total amplicons on alpha diversity

```{r, fig.width = 7, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
TrListBP[["Total"]] + ylab("total amplicons (sample_sums())")
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_total$p.value)
```

```{r, fig.width = 14, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList_lm[["Richness"]], TrList_lm[["Shannon"]], ncol = 2)
```

```{r, fig.width = 14, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]], ncol = 2)
```

- p.values for residuals lm richness vs total amplicons

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_rich_resids$p.value)
```

- p.values for residuals lm shannon vs total amplicons

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_shannon_resids$p.value)
```


## alpha diversity after **rarefaction**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# -- rarefaction using vegan package: --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}
# rare_level <- 200
set.seed(seed)

if (rare_type == "vegan"){
        
        seqtab.nochim.rare <- rrarefy(seqtab.nochim, sample = rare_level)
        
} else if (rare_type == "sample"){
        
        seqtab.nochim.rare <- t(apply(seqtab.nochim, 1, function(cnts){rarefy_sample(cnts, size = rare_level)}))
        dimnames(seqtab.nochim.rare) <- dimnames(seqtab.nochim)
        
} else {
        
        stop("rare_type must be vegan or sample")
        
}

ps.rare <- phyloseq(otu_table(seqtab.nochim.rare, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa.species))

DF_alpha_list <- calculate_alphadiversity(physeq = ps.rare, measures = alpha_div_measures)
DF_alpha <- DF_alpha_list[[1]]

alpha_div_measures2 <- alpha_div_measures
if ("Observed" %in% alpha_div_measures) {
        alpha_div_measures2[alpha_div_measures2 == "Observed"] <- "Richness" 
}

pairwise.tt_rich <- pairwise.t.test(x = DF_alpha$Richness, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

pairwise.tt_shannon <- pairwise.t.test(x = DF_alpha$Shannon, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

# NB: since Totals is now constant the residual p.values would be the same as richness directly
# pairwise.tt_rich_resids <- pairwise.t.test(x = DF_alpha$Richness_resids, g = DF_alpha[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)

# TrListBP <- plotAlphaDiversity(ps, x = group_var, color = group_var, group = group_var, measures = c("Observed", "Shannon"))
TrListBP <- boxplot_alphaDiv_fromDF(DF = DF_alpha, color = group_var, group = group_var, measures = c(alpha_div_measures2, paste(alpha_div_measures2, "resids", sep = "_")))
```

- **Rarefaction level: `r rare_level`, rarefaction type: `r rare_type`**

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]], TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]], ncol = 2)
```

- p.values for Richness

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_rich$p.value)
```

- p.values for Shannon

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(pairwise.tt_shannon$p.value)
```

- looks too similar to without rarefaction? Sanity check:

```{r, warning = FALSE, message = FALSE}
all(sample_sums(ps.rare) == rare_level)

Comp_DF <- data.frame(Sample = rownames(DF_alpha), Diff_richness = DF_alpha_no_rare$Richness - DF_alpha$Richness, Diff_shannon = DF_alpha_no_rare$Shannon - DF_alpha$Shannon)
head(arrange(Comp_DF, desc(Diff_richness)))
```

- **NB: since in dada2 data there are often no singletons, the alpha diversity measures will be less dependent on total amplicons (since it is usually the singletons that get lost by resampling to lower total amplicons amount)**


### Rarefaction curves

- calculates alpha diversity (richness) for each sample for different No of total amplicons in steps from 0 up to maximum total (chosen max_total) amplicons value.
    - samples with total number of reads < max_total have consequently shorter rarefaction curves

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# rare_curves <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "vegan")
# rare_curves_own <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "sample")

rarefaction_curves <- rarefaction_curve_own_fast(physeq = ps, group_var = group_var, max_total = rare_max_total, step_size = step_size, seed = seed)
```

```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(rarefaction_curves[["Tr_richness_col"]], rarefaction_curves[["Tr_richness_group"]], ncol = 2)
```

- dependence on total amplicons of the samples

```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
rarefaction_curves[["Tr_richness_grad"]]
```

# beta-diversity distances (non-rarefied data) and ordination

## Preprocessing (filtering)

- filtering thoughts:
    - I filter on prevalence (keeping taxa with prevalence > `r prevalence`) and taxa_sums() (keeping taxa whose taxa sums higher than the `r taxa_sums_quantile` quantile of taxa_sums)
        - prevalence filter so that SVs that are very rare and only in few samples have no effect on the distance measures
        - taxa_sums_quantile filter, so that very abundant SVs (clearly real species you would think) stay, even if they are only in a few samples, these might well separate these samples
    - because of the taxa_sums_quantile filter, I first do a DeSEQ total amplicons adjustment on the samples. NB: this only affects the taxa_sums_quantile filter, it does not affect prevalence nor the subsequent relative abundances that are used for distance calculations.
    - another "filter" that could be interesting, is to do the analysis on genus level (tax_glom) and potentially exclude NAs, so only distances between the ones we know by name


```{r, warning = FALSE, message = FALSE, echo = FALSE}
ps_taa <- adj_LS(ps) # taa for total amplicons adjusted

ps_taa_filt <- filter_taxa(ps_taa, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_taa), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt <- prune_taxa(taxa_names(ps_taa_filt), ps)
```

- `r ntaxa(ps_filt)` out of `r ntaxa(ps)` survived the filter


## calculate distances

```{r, warning = FALSE, message = FALSE, echo = FALSE}

ps_filt_ra <- transform_sample_counts(ps_filt, function(x){x/sum(x)})

dist_list <- calc_distances(ps_filt_ra, dist_methods)

# ========= recapitulate Bray Crutis Distance ==========
# mat <- as(t(otu_table(ps_filt_ra)), "matrix")
# BrayDistMatrix <- sapply(1:ncol(mat), function(y){apply(mat, 2, function(x){ sum(abs(x-mat[,y]))/sum(x + mat[,y]) })})
# all.equal(as(dist_list[["bray"]], "matrix"), BrayDistMatrix, check.attributes = FALSE) # TRUE
# ==
# == recapitulate pcoa ==
# with the distance matrix just: 
# ordi <- ape::pcoa(dist_matrix)
# this is the ordination, just like in ordination_list in calc_ordination_from_distances that can be used for the plot
# ====

pcoas <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "PCoA", group_var = group_var)   

nmdss <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "NMDS", group_var = group_var)   


```

- PCoA:

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(pcoas[["ordination_Tr_own"]], ncol = 2))
```
    
- NMDS (non-metric multidimensional scaling)

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```

