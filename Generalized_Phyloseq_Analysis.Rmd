---
title: "Generalized phyloseq analysis of dada2 data"
author: "Thorsten Brach"
date: "24/7/2017"
output: html_document
---

```{r, echo = FALSE, message=FALSE, include = FALSE}
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")
library(xtable); packageVersion("xtable")
library(RVAideMemoire); packageVersion("RVAideMemoire")
library(viridis); packageVersion("viridis")
library(scales); packageVersion("scales") # for the oob = squish option in gradient plots
library(ggthemes); packageVersion("ggthemes")
library(DESeq2); packageVersion("DESeq2")

PackageVersions <- data.frame(R = version$version.string,
                              dada2 = packageVersion("dada2"),
                              vegan = packageVersion("vegan"),
                              ggplot2 = packageVersion("ggplot2"),
                              dplyr = packageVersion("dplyr"),
                              tidyr = packageVersion("tidyr"),
                              gridExtra = packageVersion("gridExtra"),
                              xtable = packageVersion("xtable"),
                              viridis = packageVersion("viridis"),
                              scales = packageVersion("scales"),
                              ggthemes = packageVersion("ggthemes"),
                              DESeq2 = packageVersion("DESeq2"))
for (i in 1:ncol(PackageVersions)){PackageVersions[,i] <- as.character(PackageVersions[,i])}
PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version)
```

# set input parameters, load data, and generate phyloseq object

- **NB: this file only works for complete phyloseq objects**, i.e. you need to load seqtab.nochim, taxa.species, a sample_data dataframe = samdf, and a phylogenetic tree (see - file/path inputs - in the following code chunk)
    - samdf must be a data.frame in which rows are samples and columns different variables, the row/sample order must fit to seqtab.nochim, i.e. same rownames!
    - a phylogenetic tree can be generated using construct_phylogenetic_tree (in Dada_TaxonomyFunctions.R) 

- **The initial phyloseq object:**

```{r, echo = FALSE, message=FALSE}
# ---- Set input arguments including file paths ----
# - additional taxonomic level to analyse differential abundance above ASV and Phylum
extra_level = "Family"

# - filtering inputs -
prevalence <- 20 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --

# - rarefaction inputs -
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # if NULL, min(sample_sums(ps)) is used!
rare_type <- "vegan" # either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --

# - plot/statistics inputs -
taxa_are_rows = FALSE 
group_var <- "Group" # tha variable based on which samples will be grouped 
group_var_levels <- c("Young", "MiddleAged", "Old") # the factor levels of the group_var in the order you want them in your plots (set to NULL if you do not care)
second_ccp_variable <- "Sample.Integrity"
# second_ccp_variable <- NULL # for canonical correspondance analysis (see <https://f1000research.com/articles/5-1492/v1>); NB: if of interest you could add more,
# --

# - alpha diversity -
alpha_div_measures <- c("Observed", "Shannon") # not to change currently
alpha_at_genus <- FALSE
# --

# - beta diversity -
dist_methods <- c("jsd", "bray", "unifrac") # otions: see unlist(distanceMethodList)
# --

# - file/path inputs -
datapath <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/16S_Sequencing/2017-07-13_DK_age_ManiAging/Dada2_Analysis"

# NB: taxonomy, tree, and sample path should start in datapath (otherwise change code below)
taxonomy.path <- "Dada_Taxonomy/Silva_v128/Taxonomy_Silva128_minBoot50_allowMT.RData"
tree.path <- "Dada_phylogenetic_tree/phylog_tree.rds"
sample.path <- "sample_data/samdf.rds"

functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# -- 
# ----

# -- Load all data in --
# laod seqtab.nochim
load(file.path(datapath, "Dada_Data/DenoisedData.RData"))
# load QualityStats
load(file.path(datapath, "Dada_Data/QualityStats.RData"))
# load Taxonomy
load(file.path(datapath, taxonomy.path))
# load tree
tree_list <- readRDS(file.path(datapath, tree.path)) 
# load samdf
samdf <- readRDS(file.path(datapath, sample.path))

if (!is.null(group_var) && !is.null(group_var_levels)){
        samdf[[group_var]] <- factor(samdf[[group_var]], levels = group_var_levels, ordered = TRUE)
}

# sanity checks: do sample names fit
sample.names <- rownames(seqtab.nochim)
if (!all.equal(sample.names, names(F_QualityStats))) {
        stop("check sample names")
}
if (!all.equal(sample.names, as.character(ReadSummary$Sample))) {
        stop("check sample names")
}
# ----

# -- load all functions in --
source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
source(file.path(functionpath, "Dada_PlotFunctions.R"))
# ----

# -- generate phyloseq object --
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows = taxa_are_rows), 
               sample_data(samdf), 
               tax_table(taxa.species),
               phy_tree(tree_list[["fitGTR"]]$tree))
# the number of Filtered reads are added to later check the relation of alpha diversity measures to the number of filtered reads
FilteredReads <- ReadSummary[,c("Sample","FilteredReads")]
# usually should be in same order but better check:
FilteredReads <- FilteredReads[match(sample_names(ps), FilteredReads$Sample),]
sample_data(ps)$FilteredReads <- FilteredReads$FilteredReads

if (!identical(sample_names(ps), sample.names)) {
        stop("check sample names")
}

ps
# ----
```


# print input parameters and package versions used in the different dada2 analyses

```{r, echo = FALSE, message = FALSE}
# -- DadaWrapper -- 
Input_DadaWrapper <- data.frame(Argument = names(Input), 
                        Value = sapply(Input, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 5) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 6){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_DadaWrapper) <- NULL
# ----

# -- Dada_WrapperAssignTaxonomyAddSpecies --
InputSave <- InputSave[c("minBoot", "allowMultiple", "tryRC", "PathToRefs", "RefDataBase", "SpeciesDB", "PathToSave")]
Input_DadaAssignTaxonomy <- data.frame(Argument = names(unlist(InputSave)), Value = unlist(InputSave))
rownames(Input_DadaAssignTaxonomy) <- NULL
# ----

# -- construct_phylogenetic_tree -
Input_constructTree <- data.frame(Argument = names(tree_list[["Inputs"]]), 
                        Value = sapply(tree_list[["Inputs"]], function(x){ 
                                if (length(x) > 1) {
                                        "long entry"
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_constructTree) <- NULL
# ----

# -- This phyloseq analysis --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}

if (is.null(rare_max_total)){
        rare_max_total <- quantile(sample_sums(ps), probs = .25)
}

Inputs_phyloseqAnalysis <- list(extra_level = extra_level,
                                prevalence = prevalence,
                                min_obs = min_obs,
                                taxa_sums_quantile = taxa_sums_quantile,
                                seed = seed,
                                step_size = step_size,
                                rare_level = rare_level,
                                rare_type = rare_type,
                                rare_max_total = rare_max_total,
                                taxa_are_rows = taxa_are_rows,
                                group_var = group_var,
                                group_var_levels = group_var_levels,
                                second_ccp_variable = second_ccp_variable,
                                alpha_div_measures = alpha_div_measures,
                                alpha_at_genus = alpha_at_genus,
                                dist_methods = dist_methods,
                                datapath = datapath,
                                taxonomy.path = taxonomy.path,
                                tree.path = tree.path,
                                sample.path = sample.path,
                                functionpath = functionpath)


Inputs_phyloseqAnalysis <- data.frame(Argument = names(Inputs_phyloseqAnalysis), 
                        Value = sapply(Inputs_phyloseqAnalysis, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 7) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 8){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))

rownames(Inputs_phyloseqAnalysis) <- NULL
# ----


knitr::kable(PackageVersions, caption = "Package Versions DadaWrapper")
knitr::kable(Input_DadaWrapper, caption = "Input arguments DadaWrapper")

knitr::kable(Input_DadaAssignTaxonomy, caption = "Input arguments Dada_WrapperAssignTaxonomyAddSpecies")

knitr::kable(tree_list[["PackageVersions"]], caption = "Package Versions for contruct_phylogenetic_tree")
knitr::kable(Input_constructTree, caption = "Input arguments for function construct_phylogenetic_tree")

knitr::kable(PackageVersionsAnal, caption = "Package Versions for this phyloseq analysis")
knitr::kable(Inputs_phyloseqAnalysis, caption = "Input arguments for this phyloseq analysis")
```


# Plots illustrating the quality of the reads and the dada2 steps

- read cycle quality

```{r, echo = FALSE, message=FALSE}
Tr <- QS_Median_OverviewPlot(QStatsList = F_QualityStats, SampleNames = sample.names)
Tr <- Tr + 
        geom_vline(xintercept = Input$trimLeft[1], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[1], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: FW reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[1], sep = ""))

TrR <- QS_Median_OverviewPlot(QStatsList = R_QualityStats, SampleNames = sample.names)
TrR <- TrR + 
        geom_vline(xintercept = Input$trimLeft[2], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[2], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: RV reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[2], sep = ""))
```

```{r, fig.width = 8, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "QualityPlots.pdf", width = 12, height = 10)
grid.arrange(Tr, TrR, nrow = 2)
# dev.off()
```

- Error rates (fits)

```{r, echo = FALSE, message=FALSE}
if (exists("errorsFW", inherits = FALSE) && exists("errorsRV", inherits = FALSE) && !is.null(errorsFW) && !is.null(errorsRV)) {
        Tr <- plotErrors(errorsFW, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(errorsRV, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates") 
} else {
        Tr <- plotErrors(err_F, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(err_R, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates")
        
}
```

```{r, fig.width = 14, fig.height = 14, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(Tr, TrR, nrow = 2)
```

- number of reads that survived the different dada2 steps

```{r, echo = FALSE, message=FALSE}
Tr <- NoReads_StepsSimple(ReadSummary = ReadSummary, SampleNames = sample.names, sort = TRUE)
Tr <- Tr + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10),
                 text = element_text(size=14))
```
```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "NoReads_pooled.pdf", width = 10, height = 8)
Tr
# dev.off()
```

# abundances and prevalences of the `r ntaxa(ps)` amplicon sequence variants (ASVs) found in `r nsamples(ps)` samples

```{r, echo = FALSE, message=FALSE}
# phyloseq analysis starts here: so clear workspace:
# remove everything but input arguments, the phyloseq object, cbPalette, and loaded functions
rm(list = setdiff(ls(), c("cbPalette", "ps", as.character(Inputs_phyloseqAnalysis$Argument), lsf.str())))
```

```{r, echo = FALSE, message=FALSE}
df_ab_prev <- data.frame(ASV_ID = 1:ntaxa(ps), 
                         total_counts_of_ASV = taxa_sums(ps),
                         prevalence = colSums(as(otu_table(ps), "matrix") != 0),
                         sparsity = colSums(as(otu_table(ps), "matrix") == 0), 
                         mean_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){mean(x[x > 0])}),
                         median_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){median(x[x > 0])}))
df_ab_prev <- cbind(df_ab_prev, tax_table(ps))

TrrList <- plot_correlations_abundance_prev_sparsity(df_ab_prev, col = "Phylum")
TrList <- plotSVdistributions(seqtab = as(otu_table(ps), "matrix"), prevalence = prevalence)
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrrList[[1]], TrrList[[1]] + scale_y_log10(), TrrList[[2]], TrrList[[3]],
             TrrList[[4]], TrrList[[5]], ncol = 2)
# pdf(file = "AbundanceandPrevalence_p.pdf", width = 11, height = 6)
# grid.arrange(TrrList[[3]], TrrList[[5]], ncol = 2)
# dev.off()
```

```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList[[1]], TrList[[2]], TrList[[3]] + scale_y_log10(), TrList[[4]], nrow = 4)
# pdf(file = "CumAbandPrev_p.pdf", width = 10, height = 10)
# grid.arrange(TrList[[2]], TrList[[4]], ncol = 1)
# dev.off()

```


# Explore taxonomic assignment

## Removal of ASVs with Phylum = NA

```{r, echo = FALSE, message=FALSE}
Phyla <- dplyr::summarise(group_by(df_ab_prev, Phylum), ASVs = n(), PC_ASV = round(100*ASVs/ntaxa(ps),1), PC_total_prev = round(100*sum(prevalence)/sum(df_ab_prev$prevalence), 1),
                   PC_total_counts = round(100*sum(total_counts_of_ASV)/sum(df_ab_prev$total_counts_of_ASV), 1), 
                   mean_prev_in_PC = round(100*mean(prevalence)/nsamples(ps), 1),
                   mean_total_counts = round(mean(total_counts_of_ASV)),
                   median_total_counts = round(median(total_counts_of_ASV)))

knitr::kable(Phyla)
# print(xtable(Phyla, align = "|c|c|c|c|", digits = 1), include.rownames = FALSE)
ps <- subset_taxa(ps, !is.na(Phylum))
```

- `r Phyla$ASVs[is.na(Phyla$Phylum)]` ASVs were removed, leaving `r ntaxa(ps)` ASVs

## Assignment distribution of ASVs

```{r, echo = FALSE, message=FALSE}
assignment_distribution <- get_assignemnt_distribution(tax_table(ps))
knitr::kable(assignment_distribution)
```

- the Species that were assigned ambiguously:

```{r, echo = FALSE, message=FALSE}
# look at the species that have been assigned ambiguously
the_ambiguous_species <- unname(tax_table(ps)[grep(pattern = "/", tax_table(ps)[,'Species']), c('Genus', 'Species')])
colnames(the_ambiguous_species) <- c("Genus", "Species")
knitr::kable(as.data.frame(the_ambiguous_species))
```

### Is the taxonomic assignment better for more abundant/pevalent ASVs?

- NB: abundance filters ASVs are here based on total counts over all samples (taxa_sums) without the abundances in the different samples being corrected for sequencing depth (library size)

```{r, echo = FALSE, message=FALSE}
assign_vs_ab <- check_assignment_vs_abundance(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), abundanceQuantiles = seq(0, 95, by = 5))

assign_vs_prev <- check_assignment_vs_prevalence(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), prevalences = seq(0, 95, by = 5))

# TrLists <- plotTaxLevelvsAbundPrev(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"))
# TrList_ab <- TrLists[["TrList_ab"]]
# TrList_prev <- TrLists[["TrList_prev"]]
# Last3Levels <- colnames(tax_table(ps))[(ncol(tax_table(ps))-2):ncol(tax_table(ps))]
# TrList <- c(TrList_ab[Last3Levels], TrList_prev[Last3Levels])
# rm(TrLists)
```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(assign_vs_prev[[2]], assign_vs_ab[[2]], nrow = 2)
# pdf(file = "taxassignment_p.pdf", width = 8, height = 6)
# assign_vs_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
#grid.arrange(TrList[[1]] + scale_x_log10(), TrList[[4]], TrList[[2]] + scale_x_log10(), TrList[[5]], TrList[[3]] + scale_x_log10(), TrList[[6]], ncol = 2)
```



# raw **alpha-diversity**, i.e. without correction for total counts in the samples (i.e. no rarefying)

- see <https://github.com/benjjneb/dada2/issues/317> 
- NB: estimate_richness warns if no singletons are in the data, i.e. if !any(otu_table(ps) == 1) = TRUE (= !any(seqtab.nochim == 1))
    - dada2 seqtabs when obtained with dada( , pooled = FALSE) tend to be without singletons, most likely because low abundance ASVs are considered errors from more abundant ASVs

```{r, message = FALSE, warning = FALSE, echo = FALSE}
alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps, alpha_div_measures = alpha_div_measures)
DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
# generate a nice table of the p.values
p_values_wide <- arrange_p_values(pairwise_list)
# generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             ncol = 2)
#dev.off()


```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```


# alpha diversity after **rarefying**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# -- rarefaction using vegan package: --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}
# rare_level <- 200
set.seed(seed)

if (rare_type == "vegan"){
        
        seqtab.nochim.rare <- rrarefy(as(otu_table(ps), "matrix"), sample = rare_level)
        
} else if (rare_type == "sample"){
        
        seqtab.nochim.rare <- t(apply(as(otu_table(ps), "matrix"), 1, function(cnts){rarefy_sample(cnts, size = rare_level)}))
        dimnames(seqtab.nochim.rare) <- dimnames(as(otu_table(ps), "matrix"))
        
} else {
        
        stop("rare_type must be vegan or sample")
        
}

ps.rare <- ps
otu_table(ps.rare) <- otu_table(seqtab.nochim.rare, taxa_are_rows = taxa_are_rows)

alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps.rare, alpha_div_measures = alpha_div_measures)
DF_alpha_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
p_values_wide <- arrange_p_values(pairwise_list)
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)

# add in addition lm plots to the old sample_sums
TrList_lm_PreRareTotal <- plot_alphaDivVSoriginalTotalSampleCounts(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)
TrrList <- plot_alphaDivVSoriginalTotalSampleCounts2(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)

# png(file = "alpha_div_no_pool.png", width = 500, height = 250)
# grid.arrange(TrList_lm[["Richness"]], TrListBP[["Richness"]],
#              layout_matrix = matrix(c(1,1,2), nrow = 1))
# dev.off()
```

- **Rarefaction level: `r rare_level`, rarefaction type: `r rare_type`**

```{r, fig.width = 14, fig.height = 36, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             TrList_lm_PreRareTotal[["Richness"]], TrList_lm_PreRareTotal[["Shannon"]],
             ncol = 2)
# dev.off()
```

- p.values:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)
- NB: R is smart enough to not give coefficients for total_counts when it is constant (which it is after rarefying).

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
```


- comparison: did rarefying change fits to total counts and filtered_reads

```{r, fig.width = 14, fig.height = 24, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total"]][["Richness"]], TrrList[["TrList_total"]][["Shannon"]],
             TrrList[["TrList_filtered_reads"]][["Richness"]], TrrList[["TrList_filtered_reads"]][["Shannon"]],
             ncol = 1)
# dev.off()
```

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total_one"]][["Richness"]], TrrList[["TrList_total_one"]][["Shannon"]],
             TrrList[["TrList_filtered_reads_one"]][["Richness"]], TrrList[["TrList_filtered_reads_one"]][["Shannon"]],
             ncol = 2)
# dev.off()

```


- looks too similar to without rarefying? Sanity check:

```{r, warning = FALSE, message = FALSE}
all(sample_sums(ps.rare) == rare_level)
DF_alpha <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
Comp_DF <- data.frame(Sample = rownames(DF_alpha), Diff_richness = DF_alpha_no_rare$Richness - DF_alpha$Richness, Diff_shannon = DF_alpha_no_rare$Shannon - DF_alpha$Shannon)
head(arrange(Comp_DF, desc(Diff_richness)))
```

- **NB: since in dada2 data (from dada( , pooled = FALSE)) there are often no singletons, the alpha diversity measures will be less dependent on total counts (since it is usually the singletons that get lost by rarefying to lower total counts)**
- **If you see alpha diversity differences between your groups, I would recommend to rarefy on filtered_reads and check if the difference holds**


## Rarefaction curves

- rarefaction curves calculate alpha diversity (richness) for each sample for different total counts in steps from 0 up to maximum total (chosen max_total).
    - samples with total counts < max_total have consequently shorter rarefaction curves, i.e. curves that stop before max_total

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# rare_curves <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "vegan")
# rare_curves_own <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "sample")
rarefaction_curves <- rarefaction_curve_own_fast(physeq = ps, group_var = group_var, max_total = rare_max_total, step_size = step_size, seed = seed)
```

```{r, fig.width = 12, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "rarefaction_p.pdf", width = 12, height = 10)
grid.arrange(rarefaction_curves[["Tr_richness_col"]], rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]], ncol = 1)
# dev.off()



# png(file = "rarecurves_no_pool.png", width = 700, height = 300)
# grid.arrange(rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]],
#              layout_matrix = matrix(c(1,2), nrow = 1))
# dev.off()
```


## alpha diversity at genus level (if opted for, only known genera, from rarefied counts)

```{r, message = FALSE, warning = FALSE, echo = FALSE}
if (alpha_at_genus){
        ps_gen <- tax_glom(ps.rare, "Genus", NArm = TRUE)
        alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps_gen, alpha_div_measures = alpha_div_measures)
        DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
        TrListBP <- alpha_div_wrap[["TrListBP"]]
        TrList_lm <- alpha_div_wrap[["TrList_lm"]]
        TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
        pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
        pairwise_list <- pairwise_list[!is.na(pairwise_list)]
        # generate a nice table of the p.values
        p_values_wide <- arrange_p_values(pairwise_list)
        # generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
        fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
        p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
}
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        # pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
        grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
                     TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
                     TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
                     TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
                     TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
                     ncol = 2)
        #dev.off()
}
```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_wide)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_adjustedLM)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```



# beta-diversity distances (non-rarefied data) and ordination

## Preprocessing (filtering)

- filtering strategy:
    - I filter on prevalence (keeping taxa with prevalence > `r prevalence`) and taxa_sums() (keeping taxa whose taxa sums/ total counts over all samples are above the `r taxa_sums_quantile` quantile)
        - prevalence filter so that ASVs that are very rare and only in few samples have no effect on the distance measures
        - taxa_sums_quantile filter, so that very abundant ASVs (clearly real species you would think) stay, even if they are only in a few samples. These might well separate these samples
    - because of the taxa_sums_quantile filter, I first do a DeSEQ total counts adjustment on the samples. NB: this only affects the taxa_sums_quantile filter, it does not affect prevalence nor the subsequent relative abundances that are used for distance calculations.
    - another "filter" that could be interesting, is to do the distance analysis on genus level (tax_glom) and potentially exclude NAs (I.e. doing distance analysis only on the genera we actually know)


```{r, warning = FALSE, message = FALSE, echo = FALSE}
library_size_adjust_list <- adj_LS(ps) 
ps_tca <- library_size_adjust_list[[1]]
SFs <- library_size_adjust_list[[2]]

filterList <- plot_abundance_prev_filter(physeq = ps_tca, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)

ps_tca_filt <- filter_taxa(ps_tca, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_tca), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt <- prune_taxa(taxa_names(ps_tca_filt), ps) # needed for DESeq2Apply_physeq

ps_filt_ra <- transform_sample_counts(ps_filt, function(x){x/sum(x)}) # same for ps_tca_filt

```

- `r ntaxa(ps_tca_filt)` out of `r ntaxa(ps)` ASVs survived the filter

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```

- NB: the red shaded area marks the filter area, i.e. ASVs in this area are filtered out because their prevalence is below the prevalence threshold (= `r prevalence` %) and their total counts is not above the taxa_sums_quantile (= `r taxa_sums_quantile` %)

```{r, fig.width = 10, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter2_p.pdf", width = 8, height = 8)
filterList[[2]]
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(filterList[[3]])
# print(xtable(filterList[[3]][,c(1,2,4,6:9)], align = "|c|c|c|c|c|c|c|c|", digits = 1), include.rownames = FALSE)
```


## calculate distances, test for significance, construct ordination plots

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}

dist_list <- calc_distances(ps_filt_ra, dist_methods) # produces objects of class "dist"

dist_list2 <- calc_distances(ps_tca_filt, dist_methods)

# ========= recapitulate Bray Crutis Distance ==========
# mat <- as(t(otu_table(ps_filt_ra)), "matrix")
# BrayDistMatrix <- sapply(1:ncol(mat), function(y){apply(mat, 2, function(x){ sum(abs(x-mat[,y]))/sum(x + mat[,y]) })})
# all.equal(as(dist_list[["bray"]], "matrix"), BrayDistMatrix, check.attributes = FALSE) # TRUE
# ==
# == recapitulate pcoa ==
# with the distance matrix just: 
# ordi <- ape::pcoa(dist_matrix)
# this is the ordination, just like in ordination_list in calc_ordination_from_distances that can be used for the plot
# ====

# ========= compare different ways to get the same plot ==========
# bray_dist <- phyloseq::distance(ps_filt_ra, "bray")
# 
# bray_ordi <-  phyloseq::ordinate(ps_filt_ra, method = "PCoA", distance = bray_dist)
# bray_ordi_direc <- ordinate(ps_filt_ra, method = "PCoA", distance = "bray") # and note MDS = PCoA
# identical(bray_ordi, bray_ordi_direc) # TRUE
# bray_dist_list <- calc_distances(ps_filt_ra, "bray")
# identical(bray_dist_list[[1]], bray_dist) # TRUE
# pcoa_bray <- calc_ordination_from_distances(ps_filt_ra, dist_list = bray_dist_list, ordination_type = "PCoA", group_var = group_var, coord_cor = TRUE)
# identical(pcoa_bray[["ordination_list"]][[1]], bray_ordi_direc) # TRUE
# 
# # - their plot (Callahan) - 
# evals <- bray_ordi$value$Eigenvalues
# Tr <- plot_ordination(ps_filt_ra, bray_ordi, color = "Group") +
#         coord_fixed(sqrt(evals[2] / evals[1]))
# # --
# # compare to 
# pcoa_bray[["ordination_Tr_own"]]
# # clearly same plot
# 
# # -- generate biplots to see where the species (Phyla) locate in the ordination plot
# plot_ordination(ps_filt_ra, bray_ordi,  type = "split", color = c("Group", "Phylum"))
# --

# # - cehck double principal coordinates analysis --
# DPCoA_ordi_direc <- ordinate(ps_tca_filt, method = "DPCoA")
# Tr <- plot_ordination(ps_tca_filt, DPCoA_ordi_direc, color = "Group")
# Tr <- plot_ordination(ps_tca_filt, DPCoA_ordi_direc, type = "taxa", color = "Phylum")
# # --
# ====


# == Add boxplot of the distance comparisons of the groups plus pairwise t tests ==

dist_analysis_list <- distance_t_analyse(dist_list = dist_list, physeq = ps_filt_ra, group_var = group_var)

dist_analysis_list2 <- distance_t_analyse(dist_list = dist_list2, physeq = ps_tca_filt, group_var = group_var)

# ====


# == add Permutational Multivariate Analysis of Variance Using Distance Matrix: vegan::adonis ==
group_fac <- sample_data(ps_filt_ra)[[group_var]]
d_list <- dist_list

if (length(levels(group_fac)) > 2){
        Overalls <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
        })
        
        Groupwise <- lapply(d_list, function(dist_obj){
                pairwise.perm.manova.own(dist_obj = dist_obj,
                                         group_fac = group_fac,
                                         nperm = 999,
                                         p.adj.method = "fdr")
                
        })
        
        adonis_list <- lapply(1:length(Groupwise), function(i){
                df <- rbind(Overalls[[i]], Groupwise[[i]])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
        names(adonis_list) <- names(Overalls)
        
} else {
        
        adonis_list <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
}

group_fac <- sample_data(ps_tca_filt)[[group_var]]
d_list <- dist_list2

if (length(levels(group_fac)) > 2){
        Overalls <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
        })
        
        Groupwise <- lapply(d_list, function(dist_obj){
                pairwise.perm.manova.own(dist_obj = dist_obj,
                                         group_fac = group_fac,
                                         nperm = 999,
                                         p.adj.method = "fdr")
        })
        
        adonis_list2 <- lapply(1:length(Groupwise), function(i){
                df <- rbind(Overalls[[i]], Groupwise[[i]])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
        names(adonis_list2) <- names(Overalls)
        
} else {
        
        adonis_list2 <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
}
# ====

# == construct ordination plots ==

pcoas <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "PCoA", group_var = group_var, coord_cor = TRUE) 

TrList_ra <- vector(mode = "list", length = 2*length(pcoas[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_taxa"]][[i]]
}

pcoas2 <- calc_ordination_from_distances(ps_tca_filt, dist_list = dist_list2, ordination_type = "PCoA", group_var = group_var) 

TrList_counts <- vector(mode = "list", length = 2*length(pcoas2[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas2[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_taxa"]][[i]]
}

# nmdss <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "NMDS", group_var = group_var) 

# nmdss2 <- calc_ordination_from_distances(ps_tca_filt, dist_list = dist_list2, ordination_type = "NMDS", group_var = group_var) 

# ====
```

### beta diversity results relative abundance

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list[["DistanceBoxplots"]], nrow = length(dist_analysis_list[["DistanceBoxplots"]])))
# dev.off()

```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
# kable(dist_analysis_list[["DistancePValues"]][[1]])
dist_analysis_list[["DistancePValues"]]
# dev.off()
```

- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
adonis_list

# print(xtable(adonis_list[["jsd"]], align = "|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- **Ordination Plots**

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(TrList_ra, ncol = 2))
# dev.off()
```

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```

### beta diversity results for size adjusted counts

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list2[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list2[["DistanceBoxplots"]], nrow = length(dist_analysis_list2[["DistanceBoxplots"]])))
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
# kable(dist_analysis_list[["DistancePValues"]][[1]])
dist_analysis_list2[["DistancePValues"]]
# dev.off()

# pdf(file = "pcoa_jsd_ra.pdf", width = 9, height = 7)
# TrList_ra[[1]]
# dev.off()
```

- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
adonis_list2
```

- **Ordination Plots**

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrList_counts, ncol = 2))
```
    
```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss2[["ordination_Tr_own"]], ncol = 2))
```



### Canonical correspondance analysis

- NB: <https://f1000research.com/articles/5-1492/v1> did it just with log transformed counts, here with relative abundances and library size adjusted log transformed counts

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}

# canonical correspondance from relative abundance:
if (is.null(second_ccp_variable)){
        the_formula <- formula(paste("ps_filt_ra ~ ", group_var, sep = ""))       
} else {
        the_formula <- formula(paste("ps_filt_ra ~ ", group_var, " + ", second_ccp_variable, sep = ""))    
}

ps_ccpna <- ordinate(ps_filt_ra, "CCA", formula = the_formula)

TrList <- plot_canonical_correspondance(ps_ccpna, physeq = ps_filt_ra, the_formula = the_formula, group_var = group_var, second_ccp_variable = second_ccp_variable)

# canonical corresponance for log trnasformed counts
ps_tca_filt_log <- transform_sample_counts(ps_tca_filt, function(x) log(1 + x))

if (is.null(second_ccp_variable)){
        the_formula <- formula(paste("ps_tca_filt_log ~ ", group_var, sep = ""))       
} else {
        the_formula <- formula(paste("ps_tca_filt_log ~ ", group_var, " + ", second_ccp_variable, sep = ""))    
}

ps_ccpna <- ordinate(ps_tca_filt_log, "CCA", formula = the_formula)

TrList2 <- plot_canonical_correspondance(ps_ccpna, physeq = ps_tca_filt_log, the_formula = the_formula, group_var = group_var, second_ccp_variable = second_ccp_variable)

```

- canonical correspondance analysis, on ps_filt_ra (relative abundance) on top (or left), and on ps_tca_filt_log (log transformed adjusted counts) in the bottom (or right)

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
if (is.null(second_ccp_variable)){
        grid.arrange(TrList[[1]], TrList2[[1]], ncol = 2)
} else {
        do.call("grid.arrange", c(TrList, TrList2, ncol = 2))
}
```



# Differential Abundance analysis ASV level

## Heat map

- start with a heat map plot of relative abundances to visualise sparsity and abundance differences
    - NB: 0 counts are shown in red


```{r, warning = FALSE, message = FALSE, echo = FALSE}
overview <- get_overview_of_physeq(ps_tca_filt)

taxNames <- as.character(tax_table(ps_filt_ra)[, "Species"])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)

Tr <- make_heat_map_physeq(ps_filt_ra, group_var, max_abundance_for_color = .05, tax_order = NULL,
                                 tax_names = taxNames, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))

# Tr_list <- make_heat_map_physeq_levels(ps_tca_filt, group_var, max_abundance_for_color = NULL, tax_order = NULL,
#                                        tax_names = NULL, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(overview)
```

```{r, fig.width = 14, fig.height = (1 + 0.07*ntaxa(ps_filt_ra)), warning = FALSE, message = FALSE, echo = FALSE}
Tr
```

## differential prevalence analysis with fisher.test

```{r, warning = FALSE, message = FALSE, echo = FALSE}
diff_prevalence <- test_differential_prevalence(physeq = ps_filt_ra, group_var = group_var, p.adj.method = "fdr", minCount = 0L)

suppressWarnings(head_values <- sapply(diff_prevalence, function(df){
        max(which(df[, 3] < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra))/ntaxa(ps_filt_ra))

# Show at least 10 taxa even if less are significant and show max 25 even if far more are significant
head_values[head_values < 10] <- 10
head_values[head_values > 25] <- 25

prev_table_list <- lapply(1:length(diff_prevalence), function(i){
        df <- head(diff_prevalence[[i]], head_values[i])
        df <- dplyr::select(df, Family:Species, 3:6)
        colnames(df)[4:5] <- c("adj_p_val", "signi.")
        df
})
names(prev_table_list) <- names(diff_prevalence)


row_names_for_heat_maps <- lapply(prev_table_list, function(df){
        the_names <- paste(df$Family, df$Genus, df$Species)
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
        }) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(diff_prevalence), function(i){
        df <- diff_prevalence[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_ps_filt_ra <- lapply(1:length(diff_prevalence), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra)
})


heat_maps_prev <- lapply(1:length(pruned_ps_filt_ra), function(i){
        maps <- make_heat_map_physeq_levels(pruned_ps_filt_ra[[i]], group_var = group_var, max_abundance_for_color = .05, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})

```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(prev_table_list)){
        print(knitr::kable(prev_table_list[[i]], caption = names(prev_table_list)[i]))
}

# df <- prev_table_list[[2]]
# print(xtable(df, align = "|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
# 
# pdf(file = "fisher_prev.pdf", width = 10, height = 8)
# heat_maps_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_prev, ncol = 1))
```

## DeSeq2 analysis

```{r, warning = FALSE, message = FALSE, echo = FALSE}
out_list <- DESeq2Apply_physeq(physeq = ps_filt, group_var = group_var, SFs = SFs, p.adjust.method = "fdr")
DESeq2_result_list <- out_list[[1]]
physeq_DESadjust <- out_list[[2]]

suppressWarnings(head_values <- sapply(DESeq2_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt))/ntaxa(ps_filt))
head_values[head_values < 10] <- 10
head_values[head_values > 25] <- 25


DES_table_list <- lapply(1:length(DESeq2_result_list), function(i){
        df <- head(DESeq2_result_list[[i]], head_values[i])
        df <- dplyr::select(df, Family:Species, 4:5, 8:9, 13:14, 19:20)
        colnames(df)[4:7] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(DES_table_list) <- names(DESeq2_result_list)

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(DES_table_list, function(df){
        the_names <- paste(df$Family, df$Genus, df$Species)
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(DESeq2_result_list), function(i){
        df <- DESeq2_result_list[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_physeqs <- lapply(1:length(DESeq2_result_list), function(i){
        # prune_taxa(tax_orders[[i]], ps_tca_filt) 
        prune_taxa(tax_orders[[i]], physeq_DESadjust)
})


heat_maps_DES <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_DES <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_DES <- lapply(violin_plots_DES, `[[`, 8)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(DES_table_list)){
        print(knitr::kable(DES_table_list[[i]], caption = names(DES_table_list)[i]))
}

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_DES, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_DES, ncol = 1))
```


## wilcoxon test on relative abundances

### wilcoxon test including zeros (i.e. including sparsity again)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# wilcox_ra_result_list <- wilcoxTestApply_physeq(physeq = ps_filt_ra, group_var = group_var, excludeZeros = FALSE, p.adjust.method = "fdr")
# 
# 
# suppressWarnings(head_values <- sapply(wilcox_ra_result_list, function(df){
#         max(which(df$p_val_adj < 0.05))
# }))
# original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra)),
#                                    PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra))/ntaxa(ps_filt_ra))
# 
# head_values[head_values < 10] <- 10
# head_values[head_values > 25] <- 25
# 
# wilcox_ra_table_list <- lapply(1:length(wilcox_ra_result_list), function(i){
#         df <- head(wilcox_ra_result_list[[i]], head_values[i])
#         df <- dplyr::select(df, Family:Species, 4:5, 8:9, 13:14, 19:20)
#         colnames(df)[4:7] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
#         df
# })
# names(wilcox_ra_table_list) <- names(wilcox_ra_result_list)
# 
# # print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
# 
# row_names_for_heat_maps <- lapply(wilcox_ra_table_list, function(df){
#         the_names <- paste(df$Family, df$Genus, df$Species, df$signif.)
#         the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)}) # in case of ambiguous species assignment keep only first one
# 
# tax_orders <- lapply(1:length(wilcox_ra_result_list), function(i){
#         df <- wilcox_ra_result_list[[i]]
#         as.character(df$Taxon[1:head_values[i]])
# })
# 
# pruned_physeqs <- lapply(1:length(wilcox_ra_result_list), function(i){
#         prune_taxa(tax_orders[[i]], ps_filt_ra)
# })
# 
# 
# heat_maps_wilcox <- lapply(1:length(pruned_physeqs), function(i){
#         maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = .05, tax_order = tax_orders[[i]],
#                                             tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
#         maps[[i]]
# })
# 
# 
# violin_plots_wilcox <- lapply(1:length(tax_orders), function(i){
#         plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
#         plotlist[[i]]
# })
# 
# # there are 8 plots per list, only pick violin plot faceted, and logged abundance:
# violin_plots_wilcox <- lapply(violin_plots_wilcox, `[[`, 8)


# # NB: I'm a bit surprised that the order based on standardized test statistic is not fully equal to the arranged order by wilcox.test p_value
# Test <- wilcox_ra_result_list[[1]]
# identical(order(Test$p_val), 1:nrow(Test)) # clear, since arranged on p_val
# order(Test$p_val) == order(abs(Test$teststat), decreasing = TRUE) # often not equal
# order(abs(Test$teststat), decreasing = TRUE) - order(Test$p_val) # sometimes quite a difference
# # so here you could try to figure out why that is, NB: the same holds true for the W statistic given directly from wilcox.test, so wilcox.test provides a p_value that can differ from abs(W)
# order(abs(Test$W), decreasing = TRUE) - order(Test$p_val)
# order(abs(Test$W), decreasing = TRUE) - order(abs(Test$teststat), decreasing = TRUE)
# # But go through the code, it clearly happens that pValue is smaller even though W is bigger or smaller, I also tried Wy


# # NB: sparsity fisher test is the same as by diff_prevalence, if Testprev is result data.frame from diff_prevalence
# # and Test is from wilcox_ra_result_list[[1]]
# p_vals_diff <- Testprev[,2]
# p_vals_diff2 <- Test$p_val_Fisher
# all.equal(sort(p_vals_diff2), sort(p_vals_diff))
# # also adjusted when done with same method
# p_vals_diff <- Testprev[,3]
# p_vals_diff2 <- Test$p_val_Fisher_adj
# all.equal(sort(p_vals_diff2), sort(p_vals_diff))


# # NB: I tested whether excludeZeros TRUE and FALSE give consistent results
# # how? Test was excludeZeros = TRUE (a DF), Test2 was excludeZeros = FALSE
# # in cases where all values were non zero, the median and mean values should be the same
# Test <- arrange(Test, Taxon)
# Test2 <- arrange(Test2, Taxon)
# Test_grp1 <- filter(Test, Present_grp1 == 24)
# Test2_grp1 <- filter(Test2, Taxon %in% Test_grp1$Taxon)
# Test_grp1$Taxon == Test2_grp1$Taxon
# Test_grp1$Median_grp1 == Test2_grp1$Median_grp1 # all equal
# Test_grp1$Mean_grp1 == Test2_grp1$Mean_grp1 # all TRUE
# Test_grp2 <- filter(Test, Present_grp2 == 12)
# Test2_grp2 <- filter(Test2, Taxon %in% Test_grp2$Taxon)
# Test_grp2$Taxon == Test2_grp2$Taxon
# Test_grp2$Median_grp2 == Test2_grp2$Median_grp2 # all equal
# Test_grp2$Mean_grp2 == Test2_grp2$Mean_grp2 # all equal
# # in cases where both groups are full, everything should be equal
# Test_both <- filter(Test, Present_grp1 == 24, Present_grp2 == 12)
# Test2_both <- filter(Test2, Taxon %in% Test_both$Taxon)
# # the adjusted p_vals are different I assume because of the NAs in the excludeZeros = TRUE version
# # the rest should be the same
# Test_both <- select(Test_both, -p_val_adj, -significance)
# Test2_both <- select(Test2_both, -p_val_adj, -significance)
# all.equal(Test_both, Test2_both) # True
# # so I conclude in cases where all samples in a group have non zero counts, the mean and median values are equal for
# # excludeZeros = FALSE and TRUE

```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
# knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
# for (i in 1:length(wilcox_ra_table_list)){
#         print(knitr::kable(wilcox_ra_table_list[[i]], caption = names(wilcox_ra_table_list)[i]))
# }

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(heat_maps_wilcox, ncol = 1))
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(violin_plots_wilcox, ncol = 1))
```


### wilcoxon test excluding zeros 

```{r, warning = FALSE, message = FALSE, echo = FALSE}
wilcox_ra_result_list <- wilcoxTestApply_physeq(physeq = ps_filt_ra, group_var = group_var, excludeZeros = TRUE, p.adjust.method = "fdr")

suppressWarnings(head_values <- sapply(wilcox_ra_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra))/ntaxa(ps_filt_ra))
head_values[head_values < 10] <- 10
head_values[head_values > 25] <- 25

wilcox_ra_table_list <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- head(wilcox_ra_result_list[[i]], head_values[i])
        df <- dplyr::select(df, Family:Species, 4:5, 8:9, 13:14, 19:20)
        colnames(df)[4:7] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(wilcox_ra_table_list) <- names(wilcox_ra_result_list)

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(wilcox_ra_table_list, function(df){
        the_names <- paste(df$Family, df$Genus, df$Species)
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- wilcox_ra_result_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

pruned_physeqs <- lapply(1:length(wilcox_ra_result_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra)
})


heat_maps_wilcox <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = .05, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_wilcox <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_wilcox <- lapply(violin_plots_wilcox, `[[`, 8)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(wilcox_ra_table_list)){
        print(knitr::kable(wilcox_ra_table_list[[i]], caption = names(wilcox_ra_table_list)[i]))
}

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_wilcox, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_wilcox, ncol = 1))
```



## Taxon by Taxon Matrix analysis

### groupSum ranking

```{r, warning = FALSE, message = FALSE, echo = FALSE}
TbTmatrixes_list <- calculate_TbTmatrixes(ps_filt, group_var = group_var)
# NB: because ratios have been divided by geometric mean over all samples and then log transformed, each row (over all samples) sums to 0:
# max(sapply(TbTmatrixes_list[[1]], function(x){max(apply(x, 1, sum, na.rm = T))}))
TbTresult_list <- evaluate_TbTmatrixes(TbTmatrixes_list, physeq = ps_filt, group_var = group_var, p.adjust.method = "fdr")

# Currently just take the same numbers as for wilcoxon test
# suppressWarnings(head_values <- sapply(TbTresult_list, function(df){
#         # max(which(df$p_val_adj < 0.05))
#         25
# }))
# original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt)),
#                                    PC_Significant = 100*c(head_values, ntaxa(ps_filt))/ntaxa(ps_filt))
# head_values[head_values < 10] <- 10
# head_values[head_values > 25] <- 25

TbT_table_list <- lapply(1:length(TbTresult_list), function(i){
        df <- head(TbTresult_list[[i]], head_values[i])
        df <- dplyr::select(df, Family:Species, 2:3, 4:5, 10:11, 16:17)
        colnames(df)[6:7] <- c("fisher_p", "fisher_sign")
        df
})

names(TbT_table_list) <- names(TbTresult_list)

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(TbT_table_list, function(df){
        the_names <- paste(df$Family, df$Genus, df$Species)
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(TbTresult_list), function(i){
        df <- TbTresult_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

# # # # # # NB: currently using ps_filt_ra here, need something better!! # # # #
pruned_physeqs <- lapply(1:length(TbTresult_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra)
})


heat_maps_tbt <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = .05, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_tbt <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_tbt <- lapply(violin_plots_tbt, `[[`, 8)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
# knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(TbT_table_list)){
        print(knitr::kable(TbT_table_list[[i]], caption = names(TbT_table_list)[i]))
}

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_tbt, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_tbt, ncol = 1))
```


# Differential Abundance analysis at `r extra_level` level

- I chose to restart with the unfiltered phyloseq again, do taxglom and filter so again

```{r, warning = FALSE, message = FALSE, echo = FALSE}
ps_extra <- tax_glom(ps, taxrank = extra_level, NArm = FALSE)

library_size_adjust_list <- adj_LS(ps_extra) 

ps_tca_extra <- library_size_adjust_list[[1]]
SFs <- library_size_adjust_list[[2]] # NB: differs from SFs from ASVs but correlated

filterList <- plot_abundance_prev_filter(physeq = ps_tca_extra, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)

ps_tca_filt_extra <- filter_taxa(ps_tca_extra, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_tca_extra), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt_extra <- prune_taxa(taxa_names(ps_tca_filt_extra), ps_extra) # needed for DESeq2Apply_physeq

ps_filt_ra_extra <- transform_sample_counts(ps_filt_extra, function(x){x/sum(x)}) # same for ps_tca_filt

## add bar plots
Tr_bar <- plot_bar_own(physeq = ps_filt_ra_extra, x = "Sample", group_var = group_var, fill = extra_level)
#Tr_bar1 <- plot_bar_own(physeq = ps_tca_filt_extra, x = "Sample", group_var = group_var, fill = extra_level)


# table(tax_table(ps_filt_ra_extra)[, "Phylum"], useNA = "ifany")
# table(tax_table(ps_filt_ra_extra)[, "Family"], useNA = "ifany")
# table(tax_table(ps_filt_ra)[, "Phylum"], useNA = "ifany")
# table(tax_table(ps_filt_ra)[, "Family"], useNA = "ifany")

# Phyla <- table(tax_table(ps_filt_ra)[, "Phylum"], useNA = "ifany")
# Family <- table(tax_table(ps_filt_ra)[, "Family"], useNA = "ifany")
# Genera <- table(tax_table(ps_filt_ra)[, "Genus"], useNA = "ifany")
# DF <- data.frame(Level = c(rep("Phylum", length(Phyla)), rep("Family", length(Family)), rep("Genus", length(Genera))),
#                  Name = c(names(Phyla), names(Family), names(Genera)),
#                  ASVs = c(Phyla, Family, Genera))
# Tr <- ggplot(DF, aes(x = Level, y = ASVs, fill = Name))
# Tr <- Tr +
#         geom_bar(stat = "identity") +
#         facet_wrap(~ Level)
```

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```


```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
Tr_bar
#dev.off()
```

## Heat map


```{r, warning = FALSE, message = FALSE, echo = FALSE}
overview <- get_overview_of_physeq(ps_tca_filt_extra)

taxNames <- as.character(tax_table(ps_filt_ra_extra)[, extra_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)
Tr <- make_heat_map_physeq(ps_filt_ra_extra, group_var, max_abundance_for_color = NULL, tax_order = NULL,
                                 tax_names = taxNames, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))

# Tr_list <- make_heat_map_physeq_levels(ps_tca_filt, group_var, max_abundance_for_color = NULL, tax_order = NULL,
#                                        tax_names = NULL, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(overview)
```

```{r, fig.width = 14, fig.height = (4 + 0.07*ntaxa(ps_filt_ra_extra)), warning = FALSE, message = FALSE, echo = FALSE}
Tr
```

## differential prevalence analysis with fisher.test

```{r, warning = FALSE, message = FALSE, echo = FALSE}
diff_prevalence <- test_differential_prevalence(physeq = ps_filt_ra_extra, group_var = group_var, p.adj.method = "fdr", minCount = 0L)

suppressWarnings(head_values <- sapply(diff_prevalence, function(df){
        max(which(df[, 3] < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra_extra))/ntaxa(ps_filt_ra_extra))

# Show at least 10 taxa even if less are significant and show max 25 even if far more are significant
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_ra_extra))
head_values[head_values > 25] <- 25

prev_table_list <- lapply(1:length(diff_prevalence), function(i){
        df <- head(diff_prevalence[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 3:6)
        colnames(df)[2:3] <- c("adj_p_val", "signi.")
        df
})
names(prev_table_list) <- names(diff_prevalence)


row_names_for_heat_maps <- lapply(prev_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
}) # in case of ambiguous species assignment keep only first one


tax_orders <- lapply(1:length(diff_prevalence), function(i){
        df <- diff_prevalence[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_ps_filt_ra <- lapply(1:length(diff_prevalence), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_prev <- lapply(1:length(pruned_ps_filt_ra), function(i){
        maps <- make_heat_map_physeq_levels(pruned_ps_filt_ra[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})

```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(prev_table_list)){
        print(knitr::kable(prev_table_list[[i]], caption = names(prev_table_list)[i]))
}

# df <- prev_table_list[[2]]
# print(xtable(df, align = "|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
# 
# pdf(file = "fisher_prev.pdf", width = 10, height = 8)
# heat_maps_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_prev, ncol = 1))
```

## DeSeq2 analysis

```{r, warning = FALSE, message = FALSE, echo = FALSE}
out_list <- DESeq2Apply_physeq(physeq = ps_filt_extra, group_var = group_var, SFs = SFs, p.adjust.method = "fdr")
DESeq2_result_list <- out_list[[1]]
physeq_DESadjust <- out_list[[2]]

suppressWarnings(head_values <- sapply(DESeq2_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_extra))/ntaxa(ps_filt_extra))
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_extra))
head_values[head_values > 25] <- 25


DES_table_list <- lapply(1:length(DESeq2_result_list), function(i){
        df <- head(DESeq2_result_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 4:5, 8:9, 13:14, 19:20)
        colnames(df)[2:5] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(DES_table_list) <- names(DESeq2_result_list)

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(DES_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
})


tax_orders <- lapply(1:length(DESeq2_result_list), function(i){
        df <- DESeq2_result_list[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_physeqs <- lapply(1:length(DESeq2_result_list), function(i){
        # prune_taxa(tax_orders[[i]], ps_tca_filt_extra)
        prune_taxa(tax_orders[[i]], physeq_DESadjust)
})


heat_maps_DES <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_DES <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_DES <- lapply(violin_plots_DES, `[[`, 8)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(DES_table_list)){
        print(knitr::kable(DES_table_list[[i]], caption = names(DES_table_list)[i]))
}

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_DES, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_DES, ncol = 1))
```


## wilcoxon test on relative abundances

### wilcoxon test excluding zeros 

```{r, warning = FALSE, message = FALSE, echo = FALSE}
wilcox_ra_result_list <- wilcoxTestApply_physeq(physeq = ps_filt_ra_extra, group_var = group_var, excludeZeros = TRUE, p.adjust.method = "fdr")

suppressWarnings(head_values <- sapply(wilcox_ra_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra_extra))/ntaxa(ps_filt_ra_extra))
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_ra_extra))
head_values[head_values > 25] <- 25

wilcox_ra_table_list <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- head(wilcox_ra_result_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 4:5, 8:9, 13:14, 19:20)
        colnames(df)[2:5] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(wilcox_ra_table_list) <- names(wilcox_ra_result_list)

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(wilcox_ra_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- wilcox_ra_result_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

pruned_physeqs <- lapply(1:length(wilcox_ra_result_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_wilcox <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_wilcox <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_wilcox <- lapply(violin_plots_wilcox, `[[`, 8)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(wilcox_ra_table_list)){
        print(knitr::kable(wilcox_ra_table_list[[i]], caption = names(wilcox_ra_table_list)[i]))
}

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_wilcox, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_wilcox, ncol = 1))
```


## Taxon by Taxon Matrix analysis

### groupSum ranking

```{r, warning = FALSE, message = FALSE, echo = FALSE}
TbTmatrixes_list <- calculate_TbTmatrixes(ps_filt_extra, group_var = group_var)
# NB: because ratios have been divided by geometric mean over all samples and then log transformed, each row (over all samples) sums to 0:
# max(sapply(TbTmatrixes_list[[1]], function(x){max(apply(x, 1, sum, na.rm = T))}))
TbTresult_list <- evaluate_TbTmatrixes(TbTmatrixes_list, physeq = ps_filt_extra, group_var = group_var, p.adjust.method = "fdr")


# suppressWarnings(head_values <- sapply(TbTresult_list, function(df){
#         # max(which(df$p_val_adj < 0.05))
#         25
# }))
# original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt)),
#                                    PC_Significant = 100*c(head_values, ntaxa(ps_filt))/ntaxa(ps_filt))
# head_values[head_values < 10] <- 10
# head_values[head_values > 25] <- 25

TbT_table_list <- lapply(1:length(TbTresult_list), function(i){
        df <- head(TbTresult_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 2:3, 4:5, 10:11, 16:17)
        colnames(df)[4:5] <- c("fisher_p", "fisher_sign")
        df
})

names(TbT_table_list) <- names(TbTresult_list)

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(TbT_table_list, function(df){
        the_names <- paste(df[, 1], df$signi., sep = "")
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(TbTresult_list), function(i){
        df <- TbTresult_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

# NB: currently using ps_filt_ra here, need something better!!
pruned_physeqs <- lapply(1:length(TbTresult_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_tbt <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_tbt <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_tbt <- lapply(violin_plots_tbt, `[[`, 8)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
# knitr::kable(original_head_values, row.names = FALSE)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(TbT_table_list)){
        print(knitr::kable(TbT_table_list[[i]], caption = names(TbT_table_list)[i]))
}

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_tbt, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_tbt, ncol = 1))
```




# Differential Abundance analysis at Phylum level


```{r, warning = FALSE, message = FALSE, echo = FALSE}
extra_level = "Phylum"
ps_extra <- tax_glom(ps, taxrank = extra_level, NArm = FALSE)

library_size_adjust_list <- adj_LS(ps_extra) 

ps_tca_extra <- library_size_adjust_list[[1]]
SFs <- library_size_adjust_list[[2]] # NB: differs from SFs from ASVs but correlated

filterList <- plot_abundance_prev_filter(physeq = ps_tca_extra, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)

ps_tca_filt_extra <- filter_taxa(ps_tca_extra, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_tca_extra), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt_extra <- prune_taxa(taxa_names(ps_tca_filt_extra), ps_extra) # needed for DESeq2Apply_physeq

ps_filt_ra_extra <- transform_sample_counts(ps_filt_extra, function(x){x/sum(x)}) # same for ps_tca_filt

## add bar plots
Tr_bar <- plot_bar_own(physeq = ps_filt_ra_extra, x = "Sample", group_var = group_var, fill = extra_level)
```

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```


```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
Tr_bar
#dev.off()
```


## Heat map


```{r, warning = FALSE, message = FALSE, echo = FALSE}
overview <- get_overview_of_physeq(ps_tca_filt_extra)

taxNames <- as.character(tax_table(ps_filt_ra_extra)[, extra_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)

Tr <- make_heat_map_physeq(ps_filt_ra_extra, group_var, max_abundance_for_color = NULL, tax_order = NULL,
                                 tax_names = taxNames, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))

# Tr_list <- make_heat_map_physeq_levels(ps_tca_filt, group_var, max_abundance_for_color = NULL, tax_order = NULL,
#                                        tax_names = NULL, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(overview)
```

```{r, fig.width = 14, fig.height = (4 + 0.07*ntaxa(ps_filt_ra_extra)), warning = FALSE, message = FALSE, echo = FALSE}
Tr
```

## differential prevalence analysis with fisher.test

```{r, warning = FALSE, message = FALSE, echo = FALSE}
diff_prevalence <- test_differential_prevalence(physeq = ps_filt_ra_extra, group_var = group_var, p.adj.method = "fdr", minCount = 0L)

suppressWarnings(head_values <- sapply(diff_prevalence, function(df){
        max(which(df[, 3] < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra_extra))/ntaxa(ps_filt_ra_extra))

# Show at least 10 taxa even if less are significant and show max 25 even if far more are significant
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_ra_extra))
head_values[head_values > 25] <- 25

prev_table_list <- lapply(1:length(diff_prevalence), function(i){
        df <- head(diff_prevalence[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 3:6)
        colnames(df)[2:3] <- c("adj_p_val", "signi.")
        df
})
names(prev_table_list) <- names(diff_prevalence)

row_names_for_heat_maps <- lapply(prev_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
})

tax_orders <- lapply(1:length(diff_prevalence), function(i){
        df <- diff_prevalence[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_ps_filt_ra <- lapply(1:length(diff_prevalence), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_prev <- lapply(1:length(pruned_ps_filt_ra), function(i){
        maps <- make_heat_map_physeq_levels(pruned_ps_filt_ra[[i]], group_var = group_var, max_abundance_for_color = .3, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})

```

- how many significant taxa were found

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```

- the most significant taxa

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(prev_table_list)){
        print(knitr::kable(prev_table_list[[i]], caption = names(prev_table_list)[i]))
}

# df <- prev_table_list[[2]]
# print(xtable(df, align = "|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)
# 
# pdf(file = "fisher_prev.pdf", width = 10, height = 8)
# heat_maps_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_prev, ncol = 1))
```

## DeSeq2 analysis

```{r, warning = FALSE, message = FALSE, echo = FALSE}
out_list <- DESeq2Apply_physeq(physeq = ps_filt_extra, group_var = group_var, SFs = SFs, p.adjust.method = "fdr")
DESeq2_result_list <- out_list[[1]]
physeq_DESadjust <- out_list[[2]]

suppressWarnings(head_values <- sapply(DESeq2_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_extra))/ntaxa(ps_filt_extra))
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_extra))
head_values[head_values > 25] <- 25


DES_table_list <- lapply(1:length(DESeq2_result_list), function(i){
        df <- head(DESeq2_result_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 4:5, 8:9, 13:14, 19:20)
        colnames(df)[2:5] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(DES_table_list) <- names(DESeq2_result_list)

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(DES_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
})

tax_orders <- lapply(1:length(DESeq2_result_list), function(i){
        df <- DESeq2_result_list[[i]]
        df$Taxon[1:head_values[i]]
})

pruned_physeqs <- lapply(1:length(DESeq2_result_list), function(i){
        # prune_taxa(tax_orders[[i]], ps_tca_filt_extra)
        prune_taxa(tax_orders[[i]], physeq_DESadjust)
})


heat_maps_DES <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = 2000, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_DES <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_DES <- lapply(violin_plots_DES, `[[`, 8)
```

- how many significant taxa were found

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```

- the most significant taxa

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(DES_table_list)){
        print(knitr::kable(DES_table_list[[i]], caption = names(DES_table_list)[i]))
}

# print(xtable(DES_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_DES, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_DES, ncol = 1))
```


## wilcoxon test on relative abundances

### wilcoxon test excluding zeros 

```{r, warning = FALSE, message = FALSE, echo = FALSE}
wilcox_ra_result_list <- wilcoxTestApply_physeq(physeq = ps_filt_ra_extra, group_var = group_var, excludeZeros = TRUE, p.adjust.method = "fdr")

suppressWarnings(head_values <- sapply(wilcox_ra_result_list, function(df){
        max(which(df$p_val_adj < 0.05))
}))
original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt_ra_extra)),
                                   PC_Significant = 100*c(head_values, ntaxa(ps_filt_ra_extra))/ntaxa(ps_filt_ra_extra))
head_values[head_values < 10] <- min(10, ntaxa(ps_filt_ra_extra))
head_values[head_values > 25] <- 25

wilcox_ra_table_list <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- head(wilcox_ra_result_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 4:5, 8:9, 13:14, 19:20)
        colnames(df)[2:5] <- c("adj_p_val", "signi.", "fisher_p", "fisher_sign")
        df
})
names(wilcox_ra_table_list) <- names(wilcox_ra_result_list)

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(wilcox_ra_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)
        the_name <- paste(the_name, df$signi.)
}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(wilcox_ra_result_list), function(i){
        df <- wilcox_ra_result_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

pruned_physeqs <- lapply(1:length(wilcox_ra_result_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_wilcox <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = .3, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_wilcox <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_wilcox <- lapply(violin_plots_wilcox, `[[`, 8)
```

- how many significant taxa were found

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(original_head_values, row.names = FALSE)
```

- the most significant taxa

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(wilcox_ra_table_list)){
        print(knitr::kable(wilcox_ra_table_list[[i]], caption = names(wilcox_ra_table_list)[i]))
}

# print(xtable(wilcox_ra_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_wilcox, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_wilcox, ncol = 1))
```


## Taxon by Taxon Matrix analysis

### groupSum ranking

```{r, warning = FALSE, message = FALSE, echo = FALSE}
TbTmatrixes_list <- calculate_TbTmatrixes(ps_filt_extra, group_var = group_var)
# NB: because ratios have been divided by geometric mean over all samples and then log transformed, each row (over all samples) sums to 0:
# max(sapply(TbTmatrixes_list[[1]], function(x){max(apply(x, 1, sum, na.rm = T))}))
TbTresult_list <- evaluate_TbTmatrixes(TbTmatrixes_list, physeq = ps_filt_extra, group_var = group_var, p.adjust.method = "fdr")


# suppressWarnings(head_values <- sapply(TbTresult_list, function(df){
#         # max(which(df$p_val_adj < 0.05))
#         25
# }))
# original_head_values <- data.frame(Comparison = c(names(head_values), "Total"), NoSignificant = c(head_values, ntaxa(ps_filt)),
#                                    PC_Significant = 100*c(head_values, ntaxa(ps_filt))/ntaxa(ps_filt))
# head_values[head_values < 10] <- 10
# head_values[head_values > 25] <- 25

TbT_table_list <- lapply(1:length(TbTresult_list), function(i){
        df <- head(TbTresult_list[[i]], head_values[i])
        df <- dplyr::select(df, which(colnames(df) == extra_level), 2:3, 4:5, 10:11, 16:17)
        colnames(df)[4:5] <- c("fisher_p", "fisher_sign")
        df
})

names(TbT_table_list) <- names(TbTresult_list)

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

row_names_for_heat_maps <- lapply(TbT_table_list, function(df){
        the_names <- as.character(df[, which(colnames(df) == extra_level)])
        the_name <- sapply(strsplit(the_names, split = "/"), `[`, 1)}) # in case of ambiguous species assignment keep only first one

tax_orders <- lapply(1:length(TbTresult_list), function(i){
        df <- TbTresult_list[[i]]
        as.character(df$Taxon[1:head_values[i]])
})

# NB: currently using ps_filt_ra here, need something better!!
pruned_physeqs <- lapply(1:length(TbTresult_list), function(i){
        prune_taxa(tax_orders[[i]], ps_filt_ra_extra)
})


heat_maps_tbt <- lapply(1:length(pruned_physeqs), function(i){
        maps <- make_heat_map_physeq_levels(pruned_physeqs[[i]], group_var = group_var, max_abundance_for_color = NULL, tax_order = tax_orders[[i]],
                                            tax_names = row_names_for_heat_maps[[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots_tbt <- lapply(1:length(tax_orders), function(i){
        plotlist <- plot_top_abundances_boxAndviolin(physeq = pruned_physeqs[[i]], group_var = group_var, tax_order = tax_orders[[i]], tax_names = row_names_for_heat_maps[[i]])
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance:
violin_plots_tbt <- lapply(violin_plots_tbt, `[[`, 8)
```


```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
# knitr::kable(original_head_values, row.names = FALSE)
```

- the most significant taxa

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(TbT_table_list)){
        print(knitr::kable(TbT_table_list[[i]], caption = names(TbT_table_list)[i]))
}

# print(xtable(TbT_table_list[[1]], align = "|c|c|c|c|c|c|c|c|c|c|", digits = 4), include.rownames = FALSE)

```

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(head_values)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps_tbt, ncol = 1))
```

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(head_values)/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots_tbt, ncol = 1))
```


## Ratio plots


```{r, warning = FALSE, message = FALSE, echo = FALSE}
raw_TbTmatrixes_list <- calculate_raw_TbTmatrixes(ps_filt_extra, group_var = group_var)

taxNames <- as.character(tax_table(ps_filt_extra)[, extra_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)

FirmicutesRatios <- create_taxa_ratio_violin_plots(TbTmatrixes_list = raw_TbTmatrixes_list, physeq = ps_filt_extra, group_var = group_var, tax_names = taxNames, taxa_nom = "Firmicutes", taxa_den = NULL, test = "t.test", p_adjust = "none")

FirmicutesRatioPlots <- lapply(FirmicutesRatios, `[[`, 2)
# ADD bacteroides to Firmicutes ratio plot
```

```{r, fig.width = 14, fig.height = length(raw_TbTmatrixes_list)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(FirmicutesRatioPlots, ncol = 1))
```


### taxon vs taxon ratio tile plots (takes time, so only for few taxa like here for Phylum level)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
taxNames <- as.character(tax_table(ps_filt_extra)[, extra_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)

# TbT_tiles <- create_TbT_TilePlots(TbTmatrixes_list, physeq = ps_filt_extra, group_var = group_var, tax_names = taxNames, test = "wilcoxon")

TbT_tiles <- create_raw_TbT_TilePlots(raw_TbTmatrixes_list, physeq = ps_filt_extra, group_var = group_var, tax_names = taxNames, test = "wilcoxon")
TbT_tiles_show <- lapply(TbT_tiles, `[[`, 2)
```

```{r, fig.width = 10, fig.height = length(raw_TbTmatrixes_list)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TbT_tiles_show, ncol = 1))
```




