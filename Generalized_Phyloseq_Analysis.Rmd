---
title: "Generalized phyloseq analysis of dada2 data"
author: "Thorsten Brach"
date: "24/7/2017"
output: html_document
---

```{r, echo = FALSE, message=FALSE, include = FALSE}
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")
library(xtable); packageVersion("xtable")
library(RVAideMemoire); packageVersion("RVAideMemoire")
library(viridis); packageVersion("viridis")
library(scales); packageVersion("scales") # for the oob = squish option in gradient plots
library(ggthemes); packageVersion("ggthemes")

PackageVersions <- data.frame(R = version$version.string,
                              dada2 = packageVersion("dada2"),
                              vegan = packageVersion("vegan"),
                              ggplot2 = packageVersion("ggplot2"),
                              dplyr = packageVersion("dplyr"),
                              tidyr = packageVersion("tidyr"),
                              gridExtra = packageVersion("gridExtra"),
                              xtable = packageVersion("xtable"),
                              viridis = packageVersion("viridis"),
                              scales = packageVersion("scales"),
                              ggthemes = packageVersion("ggthemes"))
for (i in 1:ncol(PackageVersions)){PackageVersions[,i] <- as.character(PackageVersions[,i])}
PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version)
```

# set input parameters, load data, and generate phyloseq object

- **NB: this file only works for complete phyloseq objects**, i.e. you need to load seqtab.nochim, taxa.species, a sample_data dataframe = samdf, and a phylogenetic tree (see - file/path inputs - in the following code chunk)
    - samdf must be a data.frame in which rows are samples and columns different variables, the row/sample order must fit to seqtab.nochim, i.e. same rownames!
    - a phylogenetic tree can be generated using construct_phylogenetic_tree (in Dada_TaxonomyFunctions.R) 

- **The initial phyloseq object:**

```{r, echo = FALSE, message=FALSE}
# ---- Set input arguments including file paths ----
# - filtering inputs -
prevalence <- 20 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --

# - rarefaction inputs -
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # if NULL, min(sample_sums(ps)) is used!
rare_type <- "vegan" # either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --

# - plot/statistics inputs -
taxa_are_rows = FALSE 
group_var <- "Group" # tha variable based on which samples will be grouped 
group_var_levels <- c("Young", "MiddleAged", "Old") # the factor levels of the group_var in the order you want them in your plots (set to NULL if you do not care)
second_ccp_variable <- "Sample.Integrity"
# second_ccp_variable <- NULL # for canonical correspondance analysis (see <https://f1000research.com/articles/5-1492/v1>); NB: if of interest you could add more,
# --

# - alpha diversity -
alpha_div_measures <- c("Observed", "Shannon") # not to change currently
alpha_at_genus <- FALSE
# --

# - beta diversity -
dist_methods <- c("jsd", "bray", "unifrac") # otions: see unlist(distanceMethodList)
# --

# - file/path inputs -
datapath <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/16S_Sequencing/2017-07-13_DK_age_ManiAging/Dada2_Analysis"

# NB: taxonomy, tree, and sample path should start in datapath (otherwise change code below)
taxonomy.path <- "Dada_Taxonomy/Silva_v128/Taxonomy_Silva128_minBoot50_allowMT.RData"
tree.path <- "Dada_phylogenetic_tree/phylog_tree.rds"
sample.path <- "sample_data/samdf.rds"

functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# -- 
# ----

# -- Load all data in --
# laod seqtab.nochim
load(file.path(datapath, "Dada_Data/DenoisedData.RData"))
# load QualityStats
load(file.path(datapath, "Dada_Data/QualityStats.RData"))
# load Taxonomy
load(file.path(datapath, taxonomy.path))
# load tree
tree_list <- readRDS(file.path(datapath, tree.path)) 
# load samdf
samdf <- readRDS(file.path(datapath, sample.path))

if (!is.null(group_var) && !is.null(group_var_levels)){
        samdf[[group_var]] <- factor(samdf[[group_var]], levels = group_var_levels, ordered = TRUE)
}

# sanity checks: do sample names fit
sample.names <- rownames(seqtab.nochim)
if (!all.equal(sample.names, names(F_QualityStats))) {
        stop("check sample names")
}
if (!all.equal(sample.names, as.character(ReadSummary$Sample))) {
        stop("check sample names")
}
# ----

# -- load all functions in --
source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
source(file.path(functionpath, "Dada_PlotFunctions.R"))
# ----

# -- generate phyloseq object --
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows = taxa_are_rows), 
               sample_data(samdf), 
               tax_table(taxa.species),
               phy_tree(tree_list[["fitGTR"]]$tree))
# the number of Filtered reads are added to later check the relation of alpha diversity measures to the number of filtered reads
FilteredReads <- ReadSummary[,c("Sample","FilteredReads")]
# usually should be in same order but better check:
FilteredReads <- FilteredReads[match(sample_names(ps), FilteredReads$Sample),]
sample_data(ps)$FilteredReads <- FilteredReads$FilteredReads

if (!identical(sample_names(ps), sample.names)) {
        stop("check sample names")
}

ps
# ----
```


# print input parameters and package versions used in the different dada2 analyses

```{r, echo = FALSE, message = FALSE}
# -- DadaWrapper -- 
Input_DadaWrapper <- data.frame(Argument = names(Input), 
                        Value = sapply(Input, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 5) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 6){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_DadaWrapper) <- NULL
# ----

# -- Dada_WrapperAssignTaxonomyAddSpecies --
InputSave <- InputSave[c("minBoot", "allowMultiple", "tryRC", "PathToRefs", "RefDataBase", "SpeciesDB", "PathToSave")]
Input_DadaAssignTaxonomy <- data.frame(Argument = names(unlist(InputSave)), Value = unlist(InputSave))
rownames(Input_DadaAssignTaxonomy) <- NULL
# ----

# -- construct_phylogenetic_tree -
Input_constructTree <- data.frame(Argument = names(tree_list[["Inputs"]]), 
                        Value = sapply(tree_list[["Inputs"]], function(x){ 
                                if (length(x) > 1) {
                                        "long entry"
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_constructTree) <- NULL
# ----

# -- This phyloseq analysis --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}

if (is.null(rare_max_total)){
        rare_max_total <- quantile(sample_sums(ps), probs = .25)
}

Inputs_phyloseqAnalysis <- list(prevalence = prevalence,
               min_obs = min_obs,
               taxa_sums_quantile = taxa_sums_quantile,
               seed = seed,
               step_size = step_size,
               rare_level = rare_level,
               rare_type = rare_type,
               rare_max_total = rare_max_total,
               taxa_are_rows = taxa_are_rows,
               group_var = group_var,
               group_var_levels = group_var_levels,
               second_ccp_variable = second_ccp_variable,
               alpha_div_measures = alpha_div_measures,
               alpha_at_genus = alpha_at_genus,
               dist_methods = dist_methods,
               datapath = datapath,
               taxonomy.path = taxonomy.path,
               tree.path = tree.path,
               sample.path = sample.path,
               functionpath = functionpath)


Inputs_phyloseqAnalysis <- data.frame(Argument = names(Inputs_phyloseqAnalysis), 
                        Value = sapply(Inputs_phyloseqAnalysis, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 7) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 8){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))

rownames(Inputs_phyloseqAnalysis) <- NULL
# ----


knitr::kable(PackageVersions, caption = "Package Versions DadaWrapper")
knitr::kable(Input_DadaWrapper, caption = "Input arguments DadaWrapper")

knitr::kable(Input_DadaAssignTaxonomy, caption = "Input arguments Dada_WrapperAssignTaxonomyAddSpecies")

knitr::kable(tree_list[["PackageVersions"]], caption = "Package Versions for contruct_phylogenetic_tree")
knitr::kable(Input_constructTree, caption = "Input arguments for function construct_phylogenetic_tree")

knitr::kable(PackageVersionsAnal, caption = "Package Versions for this phyloseq analysis")
knitr::kable(Inputs_phyloseqAnalysis, caption = "Input arguments for this phyloseq analysis")
```


# Plots illustrating the quality of the reads and the dada2 steps

- read cycle quality

```{r, echo = FALSE, message=FALSE}
Tr <- QS_Median_OverviewPlot(QStatsList = F_QualityStats, SampleNames = sample.names)
Tr <- Tr + 
        geom_vline(xintercept = Input$trimLeft[1], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[1], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: FW reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[1], sep = ""))

TrR <- QS_Median_OverviewPlot(QStatsList = R_QualityStats, SampleNames = sample.names)
TrR <- TrR + 
        geom_vline(xintercept = Input$trimLeft[2], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[2], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: RV reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[2], sep = ""))
```

```{r, fig.width = 8, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "QualityPlots.pdf", width = 12, height = 10)
grid.arrange(Tr, TrR, nrow = 2)
# dev.off()
```

- Error rates (fits)

```{r, echo = FALSE, message=FALSE}
if (exists("errorsFW", inherits = FALSE) && exists("errorsRV", inherits = FALSE) && !is.null(errorsFW) && !is.null(errorsRV)) {
        Tr <- plotErrors(errorsFW, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(errorsRV, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates") 
} else {
        Tr <- plotErrors(err_F, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(err_R, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates")
        
}
```

```{r, fig.width = 14, fig.height = 14, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(Tr, TrR, nrow = 2)
```

- number of reads that survived the different dada2 steps

```{r, echo = FALSE, message=FALSE}
Tr <- NoReads_StepsSimple(ReadSummary = ReadSummary, SampleNames = sample.names, sort = TRUE)
Tr <- Tr + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10),
                 text = element_text(size=14))
```
```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "NoReads_pooled.pdf", width = 10, height = 8)
Tr
# dev.off()
```

# abundances and prevalences of the `r ntaxa(ps)` amplicon sequence variants (ASVs) found in `r nsamples(ps)` samples

```{r, echo = FALSE, message=FALSE}
# phyloseq analysis starts here: so clear workspace:
# remove everything but input arguments, the phyloseq object, cbPalette, and loaded functions
rm(list = setdiff(ls(), c("cbPalette", "ps", as.character(Inputs_phyloseqAnalysis$Argument), lsf.str())))
```

```{r, echo = FALSE, message=FALSE}
df_ab_prev <- data.frame(ASV_ID = 1:ntaxa(ps), 
                         total_counts_of_ASV = taxa_sums(ps),
                         prevalence = colSums(as(otu_table(ps), "matrix") != 0),
                         sparsity = colSums(as(otu_table(ps), "matrix") == 0), 
                         mean_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){mean(x[x > 0])}),
                         median_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){median(x[x > 0])}))
df_ab_prev <- cbind(df_ab_prev, tax_table(ps))

TrrList <- plot_correlations_abundance_prev_sparsity(df_ab_prev, col = "Phylum")
TrList <- plotSVdistributions(seqtab = as(otu_table(ps), "matrix"), prevalence = prevalence)
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrrList[[1]], TrrList[[1]] + scale_y_log10(), TrrList[[2]], TrrList[[3]],
             TrrList[[4]], TrrList[[5]], ncol = 2)
# pdf(file = "AbundanceandPrevalence_p.pdf", width = 12, height = 7)
# grid.arrange(TrrList[[1]] + scale_y_log10(), TrrList[[2]], ncol = 2)
# dev.off()
```

```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList[[1]], TrList[[2]], TrList[[3]] + scale_y_log10(), TrList[[4]], nrow = 4)
# pdf(file = "CumAbandPrev_p.pdf", width = 10, height = 10)
# grid.arrange(TrList[[2]], TrList[[4]], ncol = 1)
# dev.off()

```


# Explore taxonomic assignment

## Removal of ASVs with Phylum = NA

```{r, echo = FALSE, message=FALSE}
Phyla <- dplyr::summarise(group_by(df_ab_prev, Phylum), ASVs = n(), PC_ASV = round(100*ASVs/ntaxa(ps),1), PC_total_prev = round(100*sum(prevalence)/sum(df_ab_prev$prevalence), 1),
                   PC_total_counts = round(100*sum(total_counts_of_ASV)/sum(df_ab_prev$total_counts_of_ASV), 1), 
                   mean_prev_in_PC = round(100*mean(prevalence)/nsamples(ps), 1),
                   mean_total_counts = round(mean(total_counts_of_ASV)),
                   median_total_counts = round(median(total_counts_of_ASV)))

knitr::kable(Phyla)
# print(xtable(Phyla, align = "|c|c|c|c|", digits = 1), include.rownames = FALSE)
ps <- subset_taxa(ps, !is.na(Phylum))
```

- `r Phyla$ASVs[is.na(Phyla$Phylum)]` ASVs were removed, leaving `r ntaxa(ps)` ASVs

## Assignment distribution of ASVs

```{r, echo = FALSE, message=FALSE}
assignment_distribution <- get_assignemnt_distribution(tax_table(ps))
knitr::kable(assignment_distribution)
```

- the Species that were assigned ambiguously:

```{r, echo = FALSE, message=FALSE}
# look at the species that have been assigned ambiguously
the_ambiguous_species <- unname(tax_table(ps)[grep(pattern = "/", tax_table(ps)[,'Species']), c('Genus', 'Species')])
colnames(the_ambiguous_species) <- c("Genus", "Species")
knitr::kable(as.data.frame(the_ambiguous_species))
```

### Is the taxonomic assignment better for more abundant/pevalent ASVs?

- NB: abundance filters ASVs are here based on total counts over all samples (taxa_sums) without the abundances in the different samples being corrected for sequencing depth (library size)

```{r, echo = FALSE, message=FALSE}
assign_vs_ab <- check_assignment_vs_abundance(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), abundanceQuantiles = seq(0, 95, by = 5))

assign_vs_prev <- check_assignment_vs_prevalence(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), prevalences = seq(0, 95, by = 5))

# TrLists <- plotTaxLevelvsAbundPrev(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"))
# TrList_ab <- TrLists[["TrList_ab"]]
# TrList_prev <- TrLists[["TrList_prev"]]
# Last3Levels <- colnames(tax_table(ps))[(ncol(tax_table(ps))-2):ncol(tax_table(ps))]
# TrList <- c(TrList_ab[Last3Levels], TrList_prev[Last3Levels])
# rm(TrLists)
```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(assign_vs_prev[[2]], assign_vs_ab[[2]], nrow = 2)
# pdf(file = "taxassignment_p.pdf", width = 8, height = 6)
# assign_vs_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
#grid.arrange(TrList[[1]] + scale_x_log10(), TrList[[4]], TrList[[2]] + scale_x_log10(), TrList[[5]], TrList[[3]] + scale_x_log10(), TrList[[6]], ncol = 2)
```



# raw **alpha-diversity**, i.e. without correction for total counts in the samples (i.e. no rarefying)

- see <https://github.com/benjjneb/dada2/issues/317> 
- NB: estimate_richness warns if no singletons are in the data, i.e. if !any(otu_table(ps) == 1) = TRUE (= !any(seqtab.nochim == 1))
    - dada2 seqtabs when obtained with dada( , pooled = FALSE) tend to be without singletons, most likely because low abundance ASVs are considered errors from more abundant ASVs

```{r, message = FALSE, warning = FALSE, echo = FALSE}
alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps, alpha_div_measures = alpha_div_measures)
DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
# generate a nice table of the p.values
p_values_wide <- arrange_p_values(pairwise_list)
# generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             ncol = 2)
#dev.off()
```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```


# alpha diversity after **rarefying**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# -- rarefaction using vegan package: --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}
# rare_level <- 200
set.seed(seed)

if (rare_type == "vegan"){
        
        seqtab.nochim.rare <- rrarefy(as(otu_table(ps), "matrix"), sample = rare_level)
        
} else if (rare_type == "sample"){
        
        seqtab.nochim.rare <- t(apply(as(otu_table(ps), "matrix"), 1, function(cnts){rarefy_sample(cnts, size = rare_level)}))
        dimnames(seqtab.nochim.rare) <- dimnames(as(otu_table(ps), "matrix"))
        
} else {
        
        stop("rare_type must be vegan or sample")
        
}

ps.rare <- ps
otu_table(ps.rare) <- otu_table(seqtab.nochim.rare, taxa_are_rows = taxa_are_rows)

alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps.rare, alpha_div_measures = alpha_div_measures)
DF_alpha_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
p_values_wide <- arrange_p_values(pairwise_list)
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)

# add in addition lm plots to the old sample_sums
TrList_lm_PreRareTotal <- plot_alphaDivVSoriginalTotalSampleCounts(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)
TrrList <- plot_alphaDivVSoriginalTotalSampleCounts2(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)

# png(file = "alpha_div_no_pool.png", width = 500, height = 250)
# grid.arrange(TrList_lm[["Richness"]], TrListBP[["Richness"]],
#              layout_matrix = matrix(c(1,1,2), nrow = 1))
# dev.off()
```

- **Rarefaction level: `r rare_level`, rarefaction type: `r rare_type`**

```{r, fig.width = 14, fig.height = 36, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             TrList_lm_PreRareTotal[["Richness"]], TrList_lm_PreRareTotal[["Shannon"]],
             ncol = 2)
# dev.off()
```

- p.values:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)
- NB: R is smart enough to not give coefficients for total_counts when it is constant (which it is after rarefying).

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
```


- comparison: did rarefying change fits to total counts and filtered_reads

```{r, fig.width = 14, fig.height = 24, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total"]][["Richness"]], TrrList[["TrList_total"]][["Shannon"]],
             TrrList[["TrList_filtered_reads"]][["Richness"]], TrrList[["TrList_filtered_reads"]][["Shannon"]],
             ncol = 1)
# dev.off()
```

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total_one"]][["Richness"]], TrrList[["TrList_total_one"]][["Shannon"]],
             TrrList[["TrList_filtered_reads_one"]][["Richness"]], TrrList[["TrList_filtered_reads_one"]][["Shannon"]],
             ncol = 2)
# dev.off()

```


- looks too similar to without rarefying? Sanity check:

```{r, warning = FALSE, message = FALSE}
all(sample_sums(ps.rare) == rare_level)
DF_alpha <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
Comp_DF <- data.frame(Sample = rownames(DF_alpha), Diff_richness = DF_alpha_no_rare$Richness - DF_alpha$Richness, Diff_shannon = DF_alpha_no_rare$Shannon - DF_alpha$Shannon)
head(arrange(Comp_DF, desc(Diff_richness)))
```

- **NB: since in dada2 data (from dada( , pooled = FALSE)) there are often no singletons, the alpha diversity measures will be less dependent on total counts (since it is usually the singletons that get lost by rarefying to lower total counts)**
- **If you see alpha diversity differences between your groups, I would recommend to rarefy on filtered_reads and check if the difference holds**


## Rarefaction curves

- rarefaction curves calculate alpha diversity (richness) for each sample for different total counts in steps from 0 up to maximum total (chosen max_total).
    - samples with total counts < max_total have consequently shorter rarefaction curves, i.e. curves that stop before max_total

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# rare_curves <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "vegan")
# rare_curves_own <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "sample")
rarefaction_curves <- rarefaction_curve_own_fast(physeq = ps, group_var = group_var, max_total = rare_max_total, step_size = step_size, seed = seed)
```

```{r, fig.width = 12, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "rarefaction_p.pdf", width = 12, height = 10)
grid.arrange(rarefaction_curves[["Tr_richness_col"]], rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]], ncol = 1)
# dev.off()

# png(file = "rarecurves_no_pool.png", width = 700, height = 300)
# grid.arrange(rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]],
#              layout_matrix = matrix(c(1,2), nrow = 1))
# dev.off()
```


## alpha diversity at genus level (if opted for, only known genera, from rarefied counts)

```{r, message = FALSE, warning = FALSE, echo = FALSE}
if (alpha_at_genus){
        ps_gen <- tax_glom(ps.rare, "Genus", NArm = TRUE)
        alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps_gen, alpha_div_measures = alpha_div_measures)
        DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
        TrListBP <- alpha_div_wrap[["TrListBP"]]
        TrList_lm <- alpha_div_wrap[["TrList_lm"]]
        TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
        pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
        pairwise_list <- pairwise_list[!is.na(pairwise_list)]
        # generate a nice table of the p.values
        p_values_wide <- arrange_p_values(pairwise_list)
        # generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
        fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
        p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
}
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        # pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
        grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
                     TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
                     TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
                     TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
                     TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
                     ncol = 2)
        #dev.off()
}
```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_wide)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```

- coefficients and p.values of linear models using total counts or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_counts) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_adjustedLM)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```



# beta-diversity distances (non-rarefied data) and ordination

## Preprocessing (filtering)

- filtering strategy:
    - I filter on prevalence (keeping taxa with prevalence > `r prevalence`) and taxa_sums() (keeping taxa whose taxa sums/ total counts over all samples are above the `r taxa_sums_quantile` quantile)
        - prevalence filter so that ASVs that are very rare and only in few samples have no effect on the distance measures
        - taxa_sums_quantile filter, so that very abundant ASVs (clearly real species you would think) stay, even if they are only in a few samples. These might well separate these samples
    - because of the taxa_sums_quantile filter, I first do a DeSEQ total counts adjustment on the samples. NB: this only affects the taxa_sums_quantile filter, it does not affect prevalence nor the subsequent relative abundances that are used for distance calculations.
    - another "filter" that could be interesting, is to do the distance analysis on genus level (tax_glom) and potentially exclude NAs (I.e. doing distance analysis only on the genera we actually know)


```{r, warning = FALSE, message = FALSE, echo = FALSE}
ps_taa <- adj_LS(ps) # taa for total amplicons adjusted

filterList <- plot_abundance_prev_filter(physeq = ps_taa, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)

ps_taa_filt <- filter_taxa(ps_taa, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_taa), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt_ra <- transform_sample_counts(ps_taa_filt, function(x){x/sum(x)})
```

- `r ntaxa(ps_taa_filt)` out of `r ntaxa(ps)` ASVs survived the filter

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```

- NB: the red shaded area marks the filter area, i.e. ASVs in this area are filtered out because their prevalence is below the prevalence threshold (= `r prevalence` %) and their total counts is not above the taxa_sums_quantile (= `r taxa_sums_quantile` %)

```{r, fig.width = 10, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter2_p.pdf", width = 8, height = 8)
filterList[[2]]
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(filterList[[3]])
# print(xtable(filterList[[3]][,c(1,2,4,6:9)], align = "|c|c|c|c|c|c|c|c|", digits = 1), include.rownames = FALSE)
```


## calculate distances, test for significance, construct ordination plots

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}

dist_list <- calc_distances(ps_filt_ra, dist_methods) # produces objects of class "dist"

dist_list2 <- calc_distances(ps_taa_filt, dist_methods)

# ========= recapitulate Bray Crutis Distance ==========
# mat <- as(t(otu_table(ps_filt_ra)), "matrix")
# BrayDistMatrix <- sapply(1:ncol(mat), function(y){apply(mat, 2, function(x){ sum(abs(x-mat[,y]))/sum(x + mat[,y]) })})
# all.equal(as(dist_list[["bray"]], "matrix"), BrayDistMatrix, check.attributes = FALSE) # TRUE
# ==
# == recapitulate pcoa ==
# with the distance matrix just: 
# ordi <- ape::pcoa(dist_matrix)
# this is the ordination, just like in ordination_list in calc_ordination_from_distances that can be used for the plot
# ====

# ========= compare different ways to get the same plot ==========
# bray_dist <- phyloseq::distance(ps_filt_ra, "bray")
# 
# bray_ordi <-  phyloseq::ordinate(ps_filt_ra, method = "PCoA", distance = bray_dist)
# bray_ordi_direc <- ordinate(ps_filt_ra, method = "PCoA", distance = "bray") # and note MDS = PCoA
# identical(bray_ordi, bray_ordi_direc) # TRUE
# bray_dist_list <- calc_distances(ps_filt_ra, "bray")
# identical(bray_dist_list[[1]], bray_dist) # TRUE
# pcoa_bray <- calc_ordination_from_distances(ps_filt_ra, dist_list = bray_dist_list, ordination_type = "PCoA", group_var = group_var, coord_cor = TRUE)
# identical(pcoa_bray[["ordination_list"]][[1]], bray_ordi_direc) # TRUE
# 
# # - their plot (Callahan) - 
# evals <- bray_ordi$value$Eigenvalues
# Tr <- plot_ordination(ps_filt_ra, bray_ordi, color = "Group") +
#         coord_fixed(sqrt(evals[2] / evals[1]))
# # --
# # compare to 
# pcoa_bray[["ordination_Tr_own"]]
# # clearly same plot
# 
# # -- generate biplots to see where the species (Phyla) locate in the ordination plot
# plot_ordination(ps_filt_ra, bray_ordi,  type = "split", color = c("Group", "Phylum"))
# --

# # - cehck double principal coordinates analysis --
# DPCoA_ordi_direc <- ordinate(ps_taa_filt, method = "DPCoA")
# Tr <- plot_ordination(ps_taa_filt, DPCoA_ordi_direc, color = "Group")
# Tr <- plot_ordination(ps_taa_filt, DPCoA_ordi_direc, type = "taxa", color = "Phylum")
# # --
# ====


# == Add boxplot of the distance comparisons of the groups plus pairwise t tests ==

dist_analysis_list <- distance_t_analyse(dist_list = dist_list, physeq = ps_filt_ra, group_var = group_var)

dist_analysis_list2 <- distance_t_analyse(dist_list = dist_list2, physeq = ps_taa_filt, group_var = group_var)

# ====


# == add Permutational Multivariate Analysis of Variance Using Distance Matrix: vegan::adonis ==
group_fac <- sample_data(ps_filt_ra)[[group_var]]
d_list <- dist_list

if (length(levels(group_fac)) > 2){
        Overalls <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
        })
        
        Groupwise <- lapply(d_list, function(dist_obj){
                pairwise.perm.manova.own(dist_obj = dist_obj,
                                         group_fac = group_fac,
                                         nperm = 999,
                                         p.adj.method = "fdr")
                
        })
        
        adonis_list <- lapply(1:length(Groupwise), function(i){
                df <- rbind(Overalls[[i]], Groupwise[[i]])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
        names(adonis_list) <- names(Overalls)
        
} else {
        
        adonis_list <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
}

group_fac <- sample_data(ps_taa_filt)[[group_var]]
d_list <- dist_list2

if (length(levels(group_fac)) > 2){
        Overalls <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
        })
        
        Groupwise <- lapply(d_list, function(dist_obj){
                pairwise.perm.manova.own(dist_obj = dist_obj,
                                         group_fac = group_fac,
                                         nperm = 999,
                                         p.adj.method = "fdr")
        })
        
        adonis_list2 <- lapply(1:length(Groupwise), function(i){
                df <- rbind(Overalls[[i]], Groupwise[[i]])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
        names(adonis_list2) <- names(Overalls)
        
} else {
        
        adonis_list2 <- lapply(d_list, function(dist_obj){
                fit <- vegan::adonis(dist_obj ~ group_fac, permutations = 999)
                df <- data.frame(Comparison = "Overall_group_var",
                           addonis_p_value = fit$aov.tab[1, "Pr(>F)"], 
                           adonis_R2 = fit$aov.tab[1, "R2"], 
                           p_val_adj = fit$aov.tab[1, "Pr(>F)"])
                df$Significance <- ""
                df$Significance[df$p_val_adj <= .05] <- "*"
                df$Significance[df$p_val_adj <= .01] <- "**"
                df$Significance[df$p_val_adj <= .001] <- "***"
                df
        })
        
}
# ====

# == construct ordination plots ==

pcoas <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "PCoA", group_var = group_var, coord_cor = TRUE) 

TrList_ra <- vector(mode = "list", length = 2*length(pcoas[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_taxa"]][[i]]
}

pcoas2 <- calc_ordination_from_distances(ps_taa_filt, dist_list = dist_list2, ordination_type = "PCoA", group_var = group_var) 

TrList_counts <- vector(mode = "list", length = 2*length(pcoas2[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas2[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_taxa"]][[i]]
}

# nmdss <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "NMDS", group_var = group_var) 

# nmdss2 <- calc_ordination_from_distances(ps_taa_filt, dist_list = dist_list2, ordination_type = "NMDS", group_var = group_var) 

# ====
```

### beta diversity results relative abundance

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list[["DistanceBoxplots"]], nrow = length(dist_analysis_list[["DistanceBoxplots"]])))
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
# kable(dist_analysis_list[["DistancePValues"]][[1]])
dist_analysis_list[["DistancePValues"]]
# dev.off()
```

- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
adonis_list
```

- **Ordination Plots**

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(TrList_ra, ncol = 2))
# dev.off()
```

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```

### beta diversity results size adjusted counts

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list2[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list2[["DistanceBoxplots"]], nrow = length(dist_analysis_list2[["DistanceBoxplots"]])))
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
# kable(dist_analysis_list[["DistancePValues"]][[1]])
dist_analysis_list2[["DistancePValues"]]
# dev.off()
```

- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
adonis_list2
```

- **Ordination Plots**

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrList_counts, ncol = 2))
```
    
```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss2[["ordination_Tr_own"]], ncol = 2))
```



### Canonical correspondance analysis

- NB: <https://f1000research.com/articles/5-1492/v1> did it just with log transformed counts, here with relative abundances and library size adjusted log transformed counts

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}

# canonical correspondance from relative abundance:
if (is.null(second_ccp_variable)){
        the_formula <- formula(paste("ps_filt_ra ~ ", group_var, sep = ""))       
} else {
        the_formula <- formula(paste("ps_filt_ra ~ ", group_var, " + ", second_ccp_variable, sep = ""))    
}

ps_ccpna <- ordinate(ps_filt_ra, "CCA", formula = the_formula)

TrList <- plot_canonical_correspondance(ps_ccpna, physeq = ps_filt_ra, the_formula = the_formula, group_var = group_var, second_ccp_variable = second_ccp_variable)

# canonical corresponance for log trnasformed counts
ps_taa_filt_log <- transform_sample_counts(ps_taa_filt, function(x) log(1 + x))

if (is.null(second_ccp_variable)){
        the_formula <- formula(paste("ps_taa_filt_log ~ ", group_var, sep = ""))       
} else {
        the_formula <- formula(paste("ps_taa_filt_log ~ ", group_var, " + ", second_ccp_variable, sep = ""))    
}

ps_ccpna <- ordinate(ps_taa_filt_log, "CCA", formula = the_formula)

TrList2 <- plot_canonical_correspondance(ps_ccpna, physeq = ps_taa_filt_log, the_formula = the_formula, group_var = group_var, second_ccp_variable = second_ccp_variable)

```

- canonical correspondance analysis, on ps_filt_ra (relative abundance) on top (or left), and on ps_taa_filt_log (log transformed adjusted counts) in the bottom (or right)

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
if (is.null(second_ccp_variable)){
        grid.arrange(TrList[[1]], TrList2[[1]], ncol = 2)
} else {
        do.call("grid.arrange", c(TrList, TrList2, ncol = 2))
}
```

# Differential Abundance analysis

- start with a heat map plot of relative abundances to visualise sparsity and abundance differences
    - NB: 0 counts are shown in red, hopefully really only zeros


```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}
overview_list <- overviewPhyseq(ps_taa_filt, group_var = group_var, max_rel_ab_for_color = NULL)
overview_list1 <- overviewPhyseq(ps_taa_filt, group_var = group_var, max_rel_ab_for_color = .1)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(overview_list[[1]])
```

```{r, fig.width = 14, fig.height = 25, warning = FALSE, message = FALSE, echo = FALSE}
overview_list[[2]]
```

```{r, fig.width = 14, fig.height = 25, warning = FALSE, message = FALSE, echo = FALSE}
overview_list1[[2]]
```

