---
title: "Generalized phyloseq analysis of dada2 data"
author: "Thorsten Brach"
date: "24/7/2017"
output: html_document
---

```{r, echo = FALSE, message=FALSE, include = FALSE}
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")
library(xtable); packageVersion("xtable")

PackageVersions <- data.frame(R = version$version.string,
                              dada2 = packageVersion("dada2"),
                              vegan = packageVersion("vegan"),
                              ggplot2 = packageVersion("ggplot2"),
                              dplyr = packageVersion("dplyr"),
                              tidyr = packageVersion("tidyr"),
                              gridExtra = packageVersion("gridExtra"),
                              xtable = packageVersion("xtable"))
for (i in 1:ncol(PackageVersions)){PackageVersions[,i] <- as.character(PackageVersions[,i])}
PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version)
```

# set input parameters, load data, and generate phyloseq object

- **NB: this file only works for complete phyloseq objects**, i.e. you need to load seqtab.nochim, taxa.species, a sample_data dataframe = samdf, and a phylogenetic tree (see - file/path inputs - in the following code chunk)
    - samdf must be a data.frame in which rows are samples and columns different variables, the row/sample order must fit to seqtab.nochim, i.e. same rownames!
    - a phylogenetic tree can be generated using construct_phylogenetic_tree (in Dada_TaxonomyFunctions.R) 

- **The initial phyloseq object:**

```{r, echo = FALSE, message=FALSE}
# ---- Set input arguments including file paths ----
# - filtering inputs -
prevalence <- 20 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --

# - rarefaction inputs -
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # if NULL, min(sample_sums(ps)) is used!
rare_type <- "vegan" # either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --

# - plot/statistics inputs -
taxa_are_rows = FALSE 
group_var <- "Group" # tha variable based on which samples will be grouped 
group_var_levels <- c("Young", "MiddleAged", "Old") # the factor levels of the group_var in the order you want them in your plots (set to NULL if you do not care)
# --

# - alpha diversity -
alpha_div_measures <- c("Observed", "Shannon") # not to change currently
alpha_at_genus <- FALSE
# --

# - beta diversity -
dist_methods <- c("jsd", "unifrac", "wunifrac") # otions: see unlist(distanceMethodList)
# --

# - file/path inputs -
datapath <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/16S_Sequencing/2017-07-13_DK_age_ManiAging/Dada2_Analysis"

# NB: taxonomy, tree, and sample path should start in datapath (otherwise change code below)
taxonomy.path <- "Dada_Taxonomy/Silva_v128/Taxonomy_Silva128_minBoot50_allowMT.RData"
tree.path <- "Dada_phylogenetic_tree/phylog_tree.rds"
sample.path <- "sample_data/samdf.rds"

functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# -- 
# ----

# -- Load all data in --
# laod seqtab.nochim
load(file.path(datapath, "Dada_Data/DenoisedData.RData"))
# load QualityStats
load(file.path(datapath, "Dada_Data/QualityStats.RData"))
# load Taxonomy
load(file.path(datapath, taxonomy.path))
# load tree
tree_list <- readRDS(file.path(datapath, tree.path)) 
# load samdf
samdf <- readRDS(file.path(datapath, sample.path))

if (!is.null(group_var) && !is.null(group_var_levels)){
        samdf[[group_var]] <- factor(samdf[[group_var]], levels = group_var_levels, ordered = TRUE)
}

# sanity checks: do sample names fit
sample.names <- rownames(seqtab.nochim)
if (!all.equal(sample.names, names(F_QualityStats))) {
        stop("check sample names")
}
if (!all.equal(sample.names, as.character(ReadSummary$Sample))) {
        stop("check sample names")
}
# ----

# -- load all functions in --
source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
source(file.path(functionpath, "Dada_PlotFunctions.R"))
# ----

# -- generate phyloseq object --
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows = taxa_are_rows), 
               sample_data(samdf), 
               tax_table(taxa.species),
               phy_tree(tree_list[["fitGTR"]]$tree))
# the number of Filtered reads are added to later check the relation of alpha diversity measures to the number of filtered reads
FilteredReads <- ReadSummary[,c("Sample","FilteredReads")]
# usually should be in same order but better check:
FilteredReads <- FilteredReads[match(sample_names(ps), FilteredReads$Sample),]
sample_data(ps)$FilteredReads <- FilteredReads$FilteredReads

if (!identical(sample_names(ps), sample.names)) {
        stop("check sample names")
}

ps
# ----
```


# print input parameters and package versions used in the different dada2 analyses

```{r, echo = FALSE, message = FALSE}
# -- DadaWrapper -- 
Input_DadaWrapper <- data.frame(Argument = names(Input), 
                        Value = sapply(Input, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 5) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 6){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_DadaWrapper) <- NULL
# ----

# -- Dada_WrapperAssignTaxonomyAddSpecies --
InputSave <- InputSave[c("minBoot", "allowMultiple", "tryRC", "PathToRefs", "RefDataBase", "SpeciesDB", "PathToSave")]
Input_DadaAssignTaxonomy <- data.frame(Argument = names(unlist(InputSave)), Value = unlist(InputSave))
rownames(Input_DadaAssignTaxonomy) <- NULL
# ----

# -- construct_phylogenetic_tree -
Input_constructTree <- data.frame(Argument = names(tree_list[["Inputs"]]), 
                        Value = sapply(tree_list[["Inputs"]], function(x){ 
                                if (length(x) > 1) {
                                        "long entry"
                                } else {
                                        as.character(x)
                                }}))
rownames(Input_constructTree) <- NULL
# ----

# -- This phyloseq analysis --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}

if (is.null(rare_max_total)){
        rare_max_total <- quantile(sample_sums(ps), probs = .25)
}

Inputs_phyloseqAnalysis <- list(prevalence = prevalence,
               min_obs = min_obs,
               taxa_sums_quantile = taxa_sums_quantile,
               seed = seed,
               step_size = step_size,
               rare_level = rare_level,
               rare_type = rare_type,
               rare_max_total = rare_max_total,
               taxa_are_rows = taxa_are_rows,
               group_var = group_var,
               group_var_levels = group_var_levels,
               alpha_div_measures = alpha_div_measures,
               alpha_at_genus = alpha_at_genus,
               dist_methods = dist_methods,
               datapath = datapath,
               taxonomy.path = taxonomy.path,
               tree.path = tree.path,
               sample.path = sample.path,
               functionpath = functionpath)


Inputs_phyloseqAnalysis <- data.frame(Argument = names(Inputs_phyloseqAnalysis), 
                        Value = sapply(Inputs_phyloseqAnalysis, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 7) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 8){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))

rownames(Inputs_phyloseqAnalysis) <- NULL
# ----


knitr::kable(PackageVersions, caption = "Package Versions DadaWrapper")
knitr::kable(Input_DadaWrapper, caption = "Input arguments DadaWrapper")

knitr::kable(Input_DadaAssignTaxonomy, caption = "Input arguments Dada_WrapperAssignTaxonomyAddSpecies")

knitr::kable(tree_list[["PackageVersions"]], caption = "Package Versions for contruct_phylogenetic_tree")
knitr::kable(Input_constructTree, caption = "Input arguments for function construct_phylogenetic_tree")

knitr::kable(PackageVersionsAnal, caption = "Package Versions for this phyloseq analysis")
knitr::kable(Inputs_phyloseqAnalysis, caption = "Input arguments for this phyloseq analysis")
```


# Plots illustrating the quality of the reads and the dada2 steps

- read cycle quality

```{r, echo = FALSE, message=FALSE}
Tr <- QS_Median_OverviewPlot(QStatsList = F_QualityStats, SampleNames = sample.names)
Tr <- Tr + 
        geom_vline(xintercept = Input$trimLeft[1], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[1], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: FW reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[1], sep = ""))

TrR <- QS_Median_OverviewPlot(QStatsList = R_QualityStats, SampleNames = sample.names)
TrR <- TrR + 
        geom_vline(xintercept = Input$trimLeft[2], color = 'darkred', linetype = "dashed", size = .5) +
        geom_vline(xintercept = Input$truncLen[2], color = 'darkred', linetype = "dashed", size = .5) +
        ggtitle(paste("Median quality scores: RV reads. No Samples: ", length(sample.names), "; trimLeft: ", Input$trimLeft[1],
                "; truncLen: ", Input$truncLen[2], sep = ""))
```

```{r, fig.width = 8, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "QualityPlots.pdf", width = 12, height = 10)
grid.arrange(Tr, TrR, nrow = 2)
# dev.off()
```

- Error rates (fits)

```{r, echo = FALSE, message=FALSE}
if (exists("errorsFW", inherits = FALSE) && exists("errorsRV", inherits = FALSE) && !is.null(errorsFW) && !is.null(errorsRV)) {
        Tr <- plotErrors(errorsFW, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(errorsRV, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates") 
} else {
        Tr <- plotErrors(err_F, nominalQ = TRUE)
        Tr <- Tr + ggtitle("err_F error rates")
        TrR <- plotErrors(err_R, nominalQ = TRUE)
        TrR <- TrR + ggtitle("err_R error rates")
        
}
```

```{r, fig.width = 14, fig.height = 14, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(Tr, TrR, nrow = 2)
```

- number of reads that survived the different dada2 steps

```{r, echo = FALSE, message=FALSE}
Tr <- NoReads_StepsSimple(ReadSummary = ReadSummary, SampleNames = sample.names, sort = TRUE)
Tr <- Tr + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10),
                 text = element_text(size=14))
```
```{r, fig.width = 14, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "NoReads_pooled.pdf", width = 10, height = 8)
Tr
# dev.off()
```

# abundances and prevalences of the `r ntaxa(ps)` sequence variants (SVs) found in `r nsamples(ps)` samples

```{r, echo = FALSE, message=FALSE}
# phyloseq analysis starts here: so clear workspace:
# remove everything but input arguments, the phyloseq object, cbPalette, and loaded functions
rm(list = setdiff(ls(), c("cbPalette", "ps", as.character(Inputs_phyloseqAnalysis$Argument), lsf.str())))
```

```{r, echo = FALSE, message=FALSE}
df_ab_prev <- data.frame(SV_ID = 1:ntaxa(ps), 
                         total_abundance = taxa_sums(ps),
                         prevalence = colSums(as(otu_table(ps), "matrix") != 0),
                         sparsity = colSums(as(otu_table(ps), "matrix") == 0), 
                         mean_abundance_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){mean(x[x > 0])}),
                         median_abundance_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){median(x[x > 0])}))
df_ab_prev <- cbind(df_ab_prev, tax_table(ps))

TrrList <- plot_correlations_abundance_prev_sparsity(df_ab_prev, col = "Phylum")
TrList <- plotSVdistributions(seqtab = as(otu_table(ps), "matrix"), prevalence = prevalence)
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrrList[[1]], TrrList[[1]] + scale_y_log10(), TrrList[[2]], TrrList[[3]],
             TrrList[[4]], TrrList[[5]], ncol = 2)
# pdf(file = "AbundanceandPrevalence_p.pdf", width = 12, height = 7)
# grid.arrange(TrrList[[1]] + scale_y_log10(), TrrList[[2]], ncol = 2)
# dev.off()
```

```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList[[1]], TrList[[2]], TrList[[3]] + scale_y_log10(), TrList[[4]], nrow = 4)
# pdf(file = "CumAbandPrev_p.pdf", width = 10, height = 10)
# grid.arrange(TrList[[2]], TrList[[4]], ncol = 1)
# dev.off()

```


# Explore taxonomic assignment

## Removal of SVs with Phylum = NA

```{r, echo = FALSE, message=FALSE}
Phyla <- summarise(group_by(df_ab_prev, Phylum), SVs = n(), PC_SV = round(100*n()/ntaxa(ps),1), PC_total_pre = round(100*sum(prevalence)/sum(df_ab_prev$prevalence), 1),
                   PC_total_ab = round(100*sum(total_abundance)/sum(df_ab_prev$total_abundance), 1), 
                   mean_pre = round(100*mean(prevalence)/nsamples(ps), 1),
                   mean_tot_ab = round(100*mean(total_abundance)))

knitr::kable(Phyla)
# print(xtable(Phyla, align = "|c|c|c|c|", digits = 1), include.rownames = FALSE)
ps <- subset_taxa(ps, !is.na(Phylum))
```

- `r Phyla$assigned_SVs[is.na(Phyla$Phylum)]` SVs were removed, leaving `r ntaxa(ps)` SVs

## Assignment distribution

```{r, echo = FALSE, message=FALSE}
assignment_distribution <- get_assignemnt_distribution(tax_table(ps))
knitr::kable(assignment_distribution)
```

- the Species that were assigned unambiguously:

```{r, echo = FALSE, message=FALSE}
# look at the species that have been assigned ambiguously
the_ambiguous_species <- unname(tax_table(ps)[grep(pattern = "/", tax_table(ps)[,'Species']), c('Genus', 'Species')])
colnames(the_ambiguous_species) <- c("Genus", "Species")
knitr::kable(as.data.frame(the_ambiguous_species))
```

## Is the taxonomic assignment better for more abundant/pevalent SVs?

- NB: abundance filters of taxa are based on total abundance over all samples (taxa_sums) without the abundances in the different samples being corrected for sequencing depth (library size)

```{r, echo = FALSE, message=FALSE}
assign_vs_ab <- check_assignment_vs_abundance(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), abundanceQuantiles = seq(0, 95, by = 5))

assign_vs_prev <- check_assignment_vs_prevalence(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), prevalences = seq(0, 95, by = 5))

# TrLists <- plotTaxLevelvsAbundPrev(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"))
# TrList_ab <- TrLists[["TrList_ab"]]
# TrList_prev <- TrLists[["TrList_prev"]]
# Last3Levels <- colnames(tax_table(ps))[(ncol(tax_table(ps))-2):ncol(tax_table(ps))]
# TrList <- c(TrList_ab[Last3Levels], TrList_prev[Last3Levels])
# rm(TrLists)
```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(assign_vs_prev[[2]], assign_vs_ab[[2]], nrow = 2)
# pdf(file = "taxassignment_p.pdf", width = 8, height = 6)
# assign_vs_prev[[2]]
# dev.off()
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
#grid.arrange(TrList[[1]] + scale_x_log10(), TrList[[4]], TrList[[2]] + scale_x_log10(), TrList[[5]], TrList[[3]] + scale_x_log10(), TrList[[6]], ncol = 2)
```


# raw **alpha-diversity**, i.e. without correction for total amplicons (i.e. no rarefying)

- NB: estimate_richness warns if no singletons are in the data, i.e. if !any(otu_table(ps) == 1) = TRUE (= !any(seqtab.nochim == 1))
    - dada2 seqtabs when obtained with dada( , pooled = FALSE) tend to be without singletons, most likely because low abundance SVs are considered errors from more abundant SVs

```{r, message = FALSE, warning = FALSE, echo = FALSE}
alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps, alpha_div_measures = alpha_div_measures)
DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
# generate a nice table of the p.values
p_values_wide <- arrange_p_values(pairwise_list)
# generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             ncol = 2)
#dev.off()
```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total amplicons or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_amplicons) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```


# alpha diversity after **rarefying**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# -- rarefaction using vegan package: --
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}
# rare_level <- 200
set.seed(seed)

if (rare_type == "vegan"){
        
        seqtab.nochim.rare <- rrarefy(as(otu_table(ps), "matrix"), sample = rare_level)
        
} else if (rare_type == "sample"){
        
        seqtab.nochim.rare <- t(apply(as(otu_table(ps), "matrix"), 1, function(cnts){rarefy_sample(cnts, size = rare_level)}))
        dimnames(seqtab.nochim.rare) <- dimnames(as(otu_table(ps), "matrix"))
        
} else {
        
        stop("rare_type must be vegan or sample")
        
}

ps.rare <- ps
otu_table(ps.rare) <- otu_table(seqtab.nochim.rare, taxa_are_rows = taxa_are_rows)

alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps.rare, alpha_div_measures = alpha_div_measures)
DF_alpha_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
TrListBP <- alpha_div_wrap[["TrListBP"]]
TrList_lm <- alpha_div_wrap[["TrList_lm"]]
TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
pairwise_list <- pairwise_list[!is.na(pairwise_list)]
p_values_wide <- arrange_p_values(pairwise_list)
fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
p_values_adjustedLM <- do.call(rbind, fitter_coef_list)

# add in addition lm plots to the old sample_sums
TrList_lm_PreRareTotal <- plot_alphaDivVSoriginalTotalAmplicons(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)
TrrList <- plot_alphaDivVSoriginalTotalAmplicons2(DF_alpha_rare, DF_alpha_no_rare, measures = alpha_div_measures,
                                                                color = group_var)

# png(file = "alpha_div_no_pool.png", width = 500, height = 250)
# grid.arrange(TrList_lm[["Richness"]], TrListBP[["Richness"]],
#              layout_matrix = matrix(c(1,1,2), nrow = 1))
# dev.off()
```

- **Rarefaction level: `r rare_level`, rarefaction type: `r rare_type`**

```{r, fig.width = 14, fig.height = 36, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
             TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
             TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
             TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
             TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
             TrList_lm_PreRareTotal[["Richness"]], TrList_lm_PreRareTotal[["Shannon"]],
             ncol = 2)
# dev.off()
```

- p.values:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_wide)
# print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- coefficients and p.values of linear models using total amplicons or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_amplicons) or lm(richness/shannon ~ group_var + filtered_reads)
- NB: R is smart enough to not give coefficients for total_amplicons when total_amplicons is constant as it is after rarefying.

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(p_values_adjustedLM)
```


- comparison: did rarefying change fits to total amplicons and filtered_reads

```{r, fig.width = 14, fig.height = 24, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total"]][["Richness"]], TrrList[["TrList_total"]][["Shannon"]],
             TrrList[["TrList_filtered_reads"]][["Richness"]], TrrList[["TrList_filtered_reads"]][["Shannon"]],
             ncol = 1)
# dev.off()
```

```{r, fig.width = 14, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "alpha_div_rare_p.pdf", width = 10, height = 10)
grid.arrange(TrrList[["TrList_total_one"]][["Richness"]], TrrList[["TrList_total_one"]][["Shannon"]],
             TrrList[["TrList_filtered_reads_one"]][["Richness"]], TrrList[["TrList_filtered_reads_one"]][["Shannon"]],
             ncol = 2)
# dev.off()

```


- looks too similar to without rarefying? Sanity check:

```{r, warning = FALSE, message = FALSE}
all(sample_sums(ps.rare) == rare_level)
DF_alpha <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha
Comp_DF <- data.frame(Sample = rownames(DF_alpha), Diff_richness = DF_alpha_no_rare$Richness - DF_alpha$Richness, Diff_shannon = DF_alpha_no_rare$Shannon - DF_alpha$Shannon)
head(arrange(Comp_DF, desc(Diff_richness)))
```

- **NB: since in dada2 data (from dada( , pooled = FALSE)) there are often no singletons, the alpha diversity measures will be less dependent on total amplicons (since it is usually the singletons that get lost by rarefying to lower total amplicons amount)**


## Rarefaction curves

- rarefaction curves calculate alpha diversity (richness) for each sample for different No of total amplicons in steps from 0 up to maximum total (chosen max_total) amplicons value.
    - samples with total number of reads < max_total have consequently shorter rarefaction curves

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# rare_curves <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "vegan")
# rare_curves_own <- rarefaction_curve_own(physeq = ps, group_var = group_var, step_size = step_size, seed = seed, type = "sample")
rarefaction_curves <- rarefaction_curve_own_fast(physeq = ps, group_var = group_var, max_total = rare_max_total, step_size = step_size, seed = seed)
```

```{r, fig.width = 12, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "rarefaction_p.pdf", width = 12, height = 10)
grid.arrange(rarefaction_curves[["Tr_richness_col"]], rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]], ncol = 1)
# dev.off()

# png(file = "rarecurves_no_pool.png", width = 700, height = 300)
# grid.arrange(rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]],
#              layout_matrix = matrix(c(1,2), nrow = 1))
# dev.off()
```


## alpha diversity at genus level (if opted for, only known genera, from raryfied counts)

```{r, message = FALSE, warning = FALSE, echo = FALSE}
if (alpha_at_genus){
        ps_gen <- tax_glom(ps.rare, "Genus", NArm = TRUE)
        alpha_div_wrap <- alpha_diversity_wrapper(physeq = ps_gen, alpha_div_measures = alpha_div_measures)
        DF_alpha_no_rare <- alpha_div_wrap[["DF_alpha_list"]]$DF_alpha # used later for comparison plots to rarefied version
        TrListBP <- alpha_div_wrap[["TrListBP"]]
        TrList_lm <- alpha_div_wrap[["TrList_lm"]]
        TrList_lm_filt <- alpha_div_wrap[["TrList_lm_filteredReads"]]
        pairwise_list <- alpha_div_wrap[grep("pairwise", names(alpha_div_wrap))]
        pairwise_list <- pairwise_list[!is.na(pairwise_list)]
        # generate a nice table of the p.values
        p_values_wide <- arrange_p_values(pairwise_list)
        # generate a nice table of the p.values of linear fits using Total or filtered_reads as one of the predictors
        fitter_coef_list <- lapply(alpha_div_wrap[["fitter_list"]], function(fit) {as.data.frame(summary(fit)$coefficients)})
        p_values_adjustedLM <- do.call(rbind, fitter_coef_list)
}
```

```{r, fig.width = 14, fig.height = 30, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        # pdf(file = "alpha_div_no_rare_p.pdf", width = 10, height = 10)
        grid.arrange(TrListBP[["Richness"]], TrListBP[["Shannon"]],
                     TrList_lm[["Richness"]], TrList_lm[["Shannon"]],
                     TrListBP[["Richness_resids"]], TrListBP[["Shannon_resids"]],
                     TrList_lm_filt[["Richness"]], TrList_lm_filt[["Shannon"]],
                     TrListBP[["Richness_resids_FilteredReads"]], TrListBP[["Shannon_resids_FilteredReads"]],
                     ncol = 2)
        #dev.off()
}
```

- p.values of the boxplots:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_wide)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```

- coefficients and p.values of linear models using total amplicons or filtered reads as one of the predictors, i.e. lm(richness/shannon ~ group_var + total_amplicons) or lm(richness/shannon ~ group_var + filtered_reads)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (alpha_at_genus){
        knitr::kable(p_values_adjustedLM)
        # print(xtable(p_values_wide, align = "|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
}
```



# beta-diversity distances (non-rarefied data) and ordination

## Preprocessing (filtering)

- filtering thoughts:
    - I filter on prevalence (keeping taxa with prevalence > `r prevalence`) and taxa_sums() (keeping taxa whose taxa sums are above the `r taxa_sums_quantile` quantile)
        - prevalence filter so that SVs that are very rare and only in few samples have no effect on the distance measures
        - taxa_sums_quantile filter, so that very abundant SVs (clearly real species you would think) stay, even if they are only in a few samples. These might well separate these samples
    - because of the taxa_sums_quantile filter, I first do a DeSEQ total amplicons adjustment on the samples. NB: this only affects the taxa_sums_quantile filter, it does not affect prevalence nor the subsequent relative abundances that are used for distance calculations.
    - another "filter" that could be interesting, is to do the distance analysis on genus level (tax_glom) and potentially exclude NAs (I.e. doing distance analysis only on the genera we actually know)


```{r, warning = FALSE, message = FALSE, echo = FALSE}
ps_taa <- adj_LS(ps) # taa for total amplicons adjusted

filterList <- plot_abundance_prev_filter(physeq = ps_taa, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)

ps_taa_filt <- filter_taxa(ps_taa, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_taa), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt_ra <- transform_sample_counts(ps_taa_filt, function(x){x/sum(x)})
```

- `r ntaxa(ps_taa_filt)` out of `r ntaxa(ps)` survived the filter

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```

```{r, fig.width = 10, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter2_p.pdf", width = 8, height = 8)
filterList[[2]]
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(filterList[[3]])
# print(xtable(filterList[[3]][,c(1,2,4,6:9)], align = "|c|c|c|c|c|c|c|c|", digits = 1), include.rownames = FALSE)
```


## calculate distances

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}

dist_list <- calc_distances(ps_filt_ra, dist_methods)

dist_list2 <- calc_distances(ps_taa_filt, dist_methods)

# ========= recapitulate Bray Crutis Distance ==========
# mat <- as(t(otu_table(ps_filt_ra)), "matrix")
# BrayDistMatrix <- sapply(1:ncol(mat), function(y){apply(mat, 2, function(x){ sum(abs(x-mat[,y]))/sum(x + mat[,y]) })})
# all.equal(as(dist_list[["bray"]], "matrix"), BrayDistMatrix, check.attributes = FALSE) # TRUE
# ==
# == recapitulate pcoa ==
# with the distance matrix just: 
# ordi <- ape::pcoa(dist_matrix)
# this is the ordination, just like in ordination_list in calc_ordination_from_distances that can be used for the plot
# ====

pcoas <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "PCoA", group_var = group_var, coord_cor = TRUE) 

pcoas2 <- calc_ordination_from_distances(ps_taa_filt, dist_list = dist_list2, ordination_type = "PCoA", group_var = group_var) 

# nmdss <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "NMDS", group_var = group_var) 

# nmdss2 <- calc_ordination_from_distances(ps_taa_filt, dist_list = dist_list2, ordination_type = "NMDS", group_var = group_var) 

```

- **PCoA**:

- relative abundance

```{r, fig.width = 10, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p.pdf", width = 10, height = 8)
do.call("grid.arrange", c(pcoas[["ordination_Tr_own"]], ncol = 2))
# dev.off()
```

- counts:

```{r, fig.width = 10, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(pcoas2[["ordination_Tr_own"]], ncol = 2))
```
    
- **NMDS (non-metric multidimensional scaling)**

- relative abundance

```{r, fig.width = 10, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```

- counts:

```{r, fig.width = 10, fig.height = 7, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss2[["ordination_Tr_own"]], ncol = 2))
```

