---
title: "General analysis of 16S Data starting with a phyloseq object"
author: "Thorsten Brach"
date: "01/04/2018"
output: html_document
---


# Options for future improvements:

- the violin plots show currently t.test p-values, but that would mean doing it self instead of using ggpubr
- More importantly, the violin plots (plot_toptaxa_boxAndviolin) are shown as log abundances but you calculate res_lists in wilcoxon with non-logged abundances, so you should also do it with log abundances and order the logged violin plots based on these res_lists. NB: the ggpubr t.test signif values are correct because ggpubr adjusts the p_values when scale_y_log10 is used (it's really smart package). 
   - also, since you exclude 0s in the wilxcoxon you should exclude them also in the violin plots
- The thing with excluding 0 in violin plots would apply also to Tbt, but here you should work on getting TbT counts.
- a few functions you should allow to set test for ggpubr, and use wilcox.test also in the if else code, where you use wilcoxon which does not work with ggpubr.
- improve TbT method by trying the following:
    - 0 = 0, i.e. when host taxon was count 0 it should stay 0 (covers 0 and NaN = 0/0 ratio values)
    - Inf = x/0 should become rowMax + pseudocount
    - then do log and gm thing so rows sum to 0
        - I hope here that denominator taxa that were only present in a few samples have less range, i.e. contribute less to the following colSums
    - take colSums, so one row for each host taxon, 
    - Rank the rows (excluding the 0 columns)
    - normalise to nsamples != 0 (that way all values range from 0 to 1)
    - use wilcoxon, remember 0 samples are the last


```{r, echo = FALSE, message=FALSE, include = FALSE}
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")
library(xtable); packageVersion("xtable")
library(RVAideMemoire); packageVersion("RVAideMemoire")
library(viridis); packageVersion("viridis")
library(scales); packageVersion("scales") # for the oob = squish option in gradient plots
library(ggthemes); packageVersion("ggthemes")
library(DESeq2); packageVersion("DESeq2")
library(ggpubr); packageVersion("ggpubr")

PackageVersions <- data.frame(R = version$version.string,
                              phyloseq = packageVersion("phyloseq"),
                              dada2 = packageVersion("dada2"),
                              vegan = packageVersion("vegan"),
                              ggplot2 = packageVersion("ggplot2"),
                              dplyr = packageVersion("dplyr"),
                              tidyr = packageVersion("tidyr"),
                              gridExtra = packageVersion("gridExtra"),
                              xtable = packageVersion("xtable"),
                              viridis = packageVersion("viridis"),
                              scales = packageVersion("scales"),
                              ggthemes = packageVersion("ggthemes"),
                              DESeq2 = packageVersion("DESeq2"),
                              ggpubr = packageVersion("ggpubr"))

for (i in 1:ncol(PackageVersions)){
        PackageVersions[,i] <- as.character(PackageVersions[,i])
}

PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version) %>% arrange(Package)
```


# Load functions and set input parameters


```{r, echo = FALSE, message=FALSE}
# -- Load all functions in --
functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
# source(file.path(functionpath, "Dada_PlotFunctions.R"))
source(file.path(functionpath, "taxonomy_distribution_functions.R"))
source(file.path(functionpath, "alpha_diversity_functions.R"))
source(file.path(functionpath, "rarefying_functions.R"))
source(file.path(functionpath, "preprocess_filtering_functions.R"))
source(file.path(functionpath, "beta_diversity_functions.R"))
source(file.path(functionpath, "diff_abundance_functions.R"))
# ----

# - Set the taxonomic_level for the analysis -
# NB, NB: when taxaonomic_level = "Species" a lot of ASV will already be pooled in tax_glom because a lot of ASV have usually same taxonomy down to Species. 
# So if you want ASV level analysis, you have to set taxonomic_level <- NULL
taxonomic_level <- NULL 
phylum_NA_removal <- "no" # if yes you remove all ASVs that are Phylum = NA
# --

# - Define the group variable, i.e. the factor that separates the samples -
group_var <- "Group" # tha variable based on which samples will be grouped 
# group_var <- "seq_batch" # tha variable based on which samples will be grouped 
# group_var <- "batch" 
group_var_levels <- c("Young", "Old")
# group_var_levels <- c("Batch_1", "Batch_2", "Batch_3", "Batch_4", "Batch_5")
# group_var_levels <- c("Seq_1", "Seq_2", "Seq_3", "Seq_4", "Seq_5", "Seq_6", "Seq_9")
color_levels <- c(cbPalette[2], cbPalette[4]) # must be set for plots
# color_levels <- cbPalette[2:6]
names(color_levels) <- group_var_levels
shape <- NULL #option to distinguish another factor in plots based on shapes
# --

# - Filtering inputs -
prevalence <- 5 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --

# - Alpha diversity and rarifaction inputs -
alpha_div_measures <- c("Observed", "Shannon")
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # if NULL, min(sample_sums(ps)) is used!
rare_type <- "vegan" # either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --


# - beta diversity inputs -
dist_methods <- c("jsd", "unifrac") # otions: see unlist(distanceMethodList)
coord_cor <- TRUE # for the ordination plots
# --

```

# Load phyloseq (ps) object and prepare it for analysis


```{r, echo = FALSE, message=FALSE}

datapath <- "/Users/jvb740/MarieCurie_Work/DanFunDProject/DF_SampleProcessing/TueData_Processing/PhyseqObject"

ps <- readRDS(file.path(datapath, "Danfund_Own.rds"))

sample_data(ps)[[group_var]] <- factor(sample_data(ps)[[group_var]], levels = group_var_levels, ordered = TRUE)

```

- **the loaded phyloseq object has `r ntaxa(ps)` taxa (amplicon sequence variants = ASVs)**

# Print input parameters and package versions

```{r, echo = FALSE, message = FALSE}

Inputs_phyloseqAnalysis <- list(taxonomic_level = taxonomic_level,
                                phylum_NA_removal = phylum_NA_removal,
                                group_var = group_var,
                                group_var_levels = group_var_levels,
                                shape = shape,
                                prevalence = prevalence,
                                min_obs = min_obs,
                                taxa_sums_quantile = taxa_sums_quantile,
                                alpha_div_measures = alpha_div_measures,
                                seed = seed,
                                step_size = step_size,
                                rare_level = rare_level,
                                rare_type = rare_type,
                                rare_max_total = rare_max_total,
                                dist_methods = dist_methods,
                                coord_cor = coord_cor,
                                datapath = datapath,
                                functionpath = functionpath)


Inputs_phyloseqAnalysis <- data.frame(Argument = names(Inputs_phyloseqAnalysis),
                        Value = sapply(Inputs_phyloseqAnalysis, function(x){
                                if (is.null(x)){
                                        "NULL"
                                } else if (length(x) > 7) {
                                        "long entry"
                                } else if (length(x) > 1 && length(x) < 8){
                                        paste(x, collapse = "; ")
                                } else {
                                        as.character(x)
                                }}))

rownames(Inputs_phyloseqAnalysis) <- NULL

```


```{r, echo = FALSE, message = FALSE}
knitr::kable(PackageVersionsAnal, caption = "Used packages")
knitr::kable(Inputs_phyloseqAnalysis, caption = "Input arguments for this phyloseq analysis")
```

# Explore taxonomic assignment, prevalence and abundances of the `r ntaxa(ps)` ASVs (Did you choose to remove ASVs with Phylum = NA here? `r phylum_NA_removal`!)

## What is the most abundant and prevalent phylum?

- NB: there was no adjustment for library size yet, so taxa_sums (total counts) are calculated based on the unadjusted counts in the different samples

```{r, echo = FALSE, message=FALSE}
df_ab_prev <- data.frame(ASV_ID = 1:ntaxa(ps), 
                         total_counts_of_ASV = taxa_sums(ps),
                         prevalence = colSums(as(otu_table(ps), "matrix") != 0), # in how many samples is ASV present
                         sparsity = colSums(as(otu_table(ps), "matrix") == 0), # in how many samples is ASV absent
                         mean_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){mean(x[x > 0])}),
                         median_count_nonzero = apply(as(otu_table(ps), "matrix"), 2, function(x){median(x[x > 0])}))

df_ab_prev <- cbind(df_ab_prev, tax_table(ps))


Phyla <- dplyr::summarise(group_by(df_ab_prev, Phylum), 
                          ASVs = n(), 
                          PC_ASV = round(100*ASVs/ntaxa(ps),1), PC_total_prev = round(100*sum(prevalence)/sum(df_ab_prev$prevalence), 1),
                   PC_total_counts = round(100*sum(total_counts_of_ASV)/sum(df_ab_prev$total_counts_of_ASV), 1), 
                   mean_prev_in_PC = round(100*mean(prevalence)/nsamples(ps), 1),
                   mean_total_counts = round(mean(total_counts_of_ASV)),
                   median_total_counts = round(median(total_counts_of_ASV))) %>% arrange(desc(PC_total_counts), desc(ASVs), desc(PC_total_prev))

```

```{r, echo = FALSE, message=FALSE}
knitr::kable(Phyla)
```

- **Write your conclusion here:** *e.g.: there are more ASV from Firmicutes than Bacteroidetes, but the Bacteroidetes ASVs have on average more counts over all samples. The average ASV is present in less than 10% of the samples.*  



## Assignment distribution of ASVs

```{r, echo = FALSE, message=FALSE}
assignment_distribution <- get_assignemnt_distribution(tax_table(ps))
```

```{r, echo = FALSE, message=FALSE}
knitr::kable(assignment_distribution)
```

- **Write your conclusion here:** *e.g.: almost 70% of taxa/ASVs are assigned to Genus level but less than 10% to Species level*  




### Is the taxonomic assignment better for more abundant/pevalent ASVs?

- Again NB for the interpretation of the following plots: the abundance filters on the ASVs are based on total counts over all samples (taxa_sums), and the abundances have not been corrected for sequencing depth (library size) of the samples yest.

```{r, echo = FALSE, message=FALSE}
assign_vs_ab <- check_assignment_vs_abundance(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), abundanceQuantiles = seq(0, 95, by = 5))

assign_vs_prev <- check_assignment_vs_prevalence(taxa = tax_table(ps), seqtab = as(otu_table(ps), "matrix"), prevalences = seq(0, 95, by = 5))

```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(assign_vs_prev[[2]], assign_vs_ab[[2]], nrow = 2)
```

- **Write your conclusion here:** *e.g.: very clear yes, there is a trend that the more abundant and especially more prevalent ASVs are more often assigned to species level* 


## Possible removal of `r Phyla$ASVs[is.na(Phyla$Phylum)]` ASVs with Phylum = NA, here: `r phylum_NA_removal`


```{r, echo = FALSE, message=FALSE}
# - remove ASVs with Phylum == NA -
if (phylum_NA_removal == "yes"){
        ps <- phyloseq::subset_taxa(ps, !is.na(Phylum)) # kick out taxa that could not be assigned even at phylum level
}
# --

```

- **`r sum(Phyla$ASVs) - ntaxa(ps)` ASVs were removed, leaving `r ntaxa(ps)` ASVs.**



## Abundance and prevalence distributions of the `r ntaxa(ps)` amplicon sequence variants (ASVs) in `r nsamples(ps)` samples


```{r, echo = FALSE, message=FALSE}
TrrList <- plot_correlations_abundance_prev_sparsity(physeq = ps, col = "Phylum")
# TrList <- plotSVdistributions(seqtab = as(otu_table(ps), "matrix"), prevalence = prevalence)
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrrList[[1]], TrrList[[1]] + scale_y_log10(), TrrList[[2]], TrrList[[3]],
             TrrList[[4]], TrrList[[5]], ncol = 2)
# pdf(file = "AbundanceandPrevalence_p.pdf", width = 11, height = 6)
# grid.arrange(TrrList[[3]], TrrList[[5]], ncol = 2)
# dev.off()
```

- **Write your conclusion here:** *e.g.: The last two plots illustrate that ASVs with higher mean/median counts in non-zero samples (i.e. in samples where they are present) are more likely to have higher prevalence (are present in more samples). BUT really only slightly more likely because the R.square is minimal! So I there to say: the fact that a taxon grows to higher abundance when it's are present does not make it more likely to be present in many samples*



# Perform tax_glom to the chosen taxonomic_level, which is: `r if (is.null(taxonomic_level)) {"ASV"} else {taxonomic_level}`

- **NB: also the size factors for the later total count adjustment (a la DESeq2) are calculated here based on the ASV level phyloseq object, because I realised that sixe factors are less reliable (well more variable) when calculated on less taxa, which makes sense since they are based on a median ratio and I expect a median to be less stable for less taxa**
- `r ntaxa(ps)` are there before the tax_glom

```{r, echo = FALSE, message=FALSE}
# NB NB NB NB NB NB NB NB NB
# I decided to calculate the SF's always on ASV's level physeqs, based on the way it is calculated (median ratio) I think you should have at least 200 taxa
# NB: this affects DESeq and wilcoxon part, all with tca physeqks
# NB NB NB NB NB NB NB NB NB

SFs <- calc_SFs(physeq = ps)

if (!is.null(taxonomic_level)){
        ps <- phyloseq::tax_glom(ps, taxrank = taxonomic_level, NArm = FALSE)
} else {
        taxonomic_level <- "Species" # for later labelling in plots, even though in this case it is ASV level analysis but there is no strain taxonomy in taxa_table
}
```

- **`r ntaxa(ps)` remain after the tax_glom**

## Prevalence and abundance of the `r ntaxa(ps)` taxa after tax_glom in relation to the chosen prevalence (no samples: `r nsamples(ps)`) that you later use for filtering

```{r, echo = FALSE, message=FALSE}
TrList <- plotSVdistributions(seqtab = as(otu_table(ps), "matrix"), prevalence = prevalence)
```


```{r, fig.width = 14, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(TrList[[1]], TrList[[2]], TrList[[3]] + scale_y_log10(), TrList[[4]], nrow = 4)
# pdf(file = "CumAbandPrev_p.pdf", width = 10, height = 10)
# grid.arrange(TrList[[2]], TrList[[4]], ncol = 1)
# dev.off()

```

- *NB: prevalence is independent of library size adjustment, but counts are of course affected. So the exact counts leaving with prevalence filtered taxa and the total counts differ a bit between ps and ps_tca. The plots should still give an impression that removing a lot of low prevalence ASVs does not necessarily remove a lot of counts.*
- **Write your conclusion here:** *e.g.: my prevalence is low enough that clearly less than 10% of the counts will be removed*



# Alpha-diversity analysis

## Check whether sample_sums/total_counts differ between group_var levels

- **NB: ggpubr is used to add t.test (or wilcoxon) p-values, I use hide.ns if not significant, but it still leaves the bar, so if there is a bar without asterisk, it means not significantly differnt**

```{r, message = FALSE, warning = FALSE, echo = FALSE}

SampleSumList <- boxplot_sampleSums(physeq = ps, group_var = group_var, color_levels = color_levels, shape = shape, test = "t.test", p_adjust_method = "fdr",
                                    symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))

```

```{r, fig.width = 7, fig.height = 5, warning = FALSE, message = FALSE, echo = FALSE}
SampleSumList[["Tr"]]
```

- **Write your conclusion here:** *e.g.: no significant differences in the sample_sums between the group levels.*



## raw **alpha-diversity**, i.e. without correction for total counts in the samples (i.e. no rarefying)

- see <https://github.com/benjjneb/dada2/issues/317> 
- NB: estimate_richness warns if no singletons are in the data, i.e. if !any(otu_table(ps) == 1) = TRUE (= !any(seqtab.nochim == 1))
    - dada2 seqtabs when obtained with dada( , pooled = FALSE) tend to be without singletons, most likely because low abundance ASVs are considered errors from more abundant ASVs

```{r, message = FALSE, warning = FALSE, echo = FALSE}
# - calculate alpha diversity values and add the residuals of a linear fit: alpha-diversity to total_counts, since those fits are often highly significant -
DF_alpha_list <- calc_alphadiv_plusLmResids(physeq = ps, measures = alpha_div_measures)
lm_fitlist <- DF_alpha_list[[2]]
DF_alpha <- DF_alpha_list[[1]]
# --

# - calculate p-values of t.tests for the different alpha-diversity measures comparing the levels in group_var - 
alpha_div_pVals <- calc_pVals_alphdiv(DF_alpha = DF_alpha, measures = alpha_div_measures, group = group_var, test = "t.test")
# -- 

# - generate boxplots for the different alpha-diversity measures comparing the levels in group_var - 
alpha_div_boxplots <- boxplots_alphdiv(DF_alpha = DF_alpha, measures = alpha_div_measures, group = group_var, shape = shape, color_levels = color_levels, test = "t.test")
# --

# - add alpha_diversity_measure vs total counts plots with results of linear fit in title -
alpha_div_lmPlots <- lmPlots_alphdiv(DF_alpha = DF_alpha, lm_fitlist = lm_fitlist, measures = alpha_div_measures, group = 
                                             group_var, shape = shape, color_levels = color_levels, test = "t.test")
# --

TrList <- c(alpha_div_boxplots, alpha_div_lmPlots)
TrList <- TrList[order(names(TrList))] # to get the plots in the right order
```


```{r, fig.width = 14, fig.height = (length(TrList)/3)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrList, ncol = 3))
```

- p.values comparing alpha diversities between the levels in group_var

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(alpha_div_pVals)
# print(xtable(alpha_div_pVals, align = "|c|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- **Write your conclusion here:** *e.g.: level 1 has higher alpha diversity. There is a clear trend that alpha diversity gets higher with higher total_counts, but also the residuals of level 1 in a lm alpha diversity to total_counts are higher than those of level 2. Test for confounders, for example via the shape option*



## alpha diversity after **rarefying**

- **Rarefaction level: `r rare_level`, rarefaction type: `r rare_type`**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - do the rarefaction using vegan package or own sampling function: -
if (is.null(rare_level)) {
        rare_level <- min(sample_sums(ps))
}
# rare_level <- 200
set.seed(seed)

if (rare_type == "vegan"){
        
        seqtab.nochim.rare <- vegan::rrarefy(as(otu_table(ps), "matrix"), sample = rare_level)
        
} else if (rare_type == "sample"){
        
        seqtab.nochim.rare <- t(apply(as(otu_table(ps), "matrix"), 1, function(cnts){rarefy_sample(cnts, size = rare_level)}))
        dimnames(seqtab.nochim.rare) <- dimnames(as(otu_table(ps), "matrix"))
        
} else {
        
        stop("rare_type must be vegan or sample")
        
}

ps.rare <- ps
otu_table(ps.rare) <- otu_table(seqtab.nochim.rare, taxa_are_rows = taxa_are_rows(ps))
# --

# - calculate alpha diversity values and add the residuals of a linear fit: alpha-diversity to total_counts, since those fits are often highly significant -
DF_alpha_list <- calc_alphadiv_plusLmResids(physeq = ps.rare, measures = alpha_div_measures)
lm_fitlist <- DF_alpha_list[[2]]
DF_alpha <- DF_alpha_list[[1]]
# --

# - calculate p-values of t.tests for the different alpha-diversity measures comparing the levels in group_var - 
alpha_div_pVals <- calc_pVals_alphdiv(DF_alpha = DF_alpha, measures = alpha_div_measures, group = group_var, test = "t.test")
# -- 

# - generate boxplots for the different alpha-diversity measures comparing the levels in group_var - 
alpha_div_boxplots <- boxplots_alphdiv(DF_alpha = DF_alpha, measures = alpha_div_measures, group = group_var, shape = shape, color_levels = color_levels, test = "t.test")
# --

# - add alpha_diversity_measure vs total counts plots with results of linear fit in title -
alpha_div_lmPlots <- lmPlots_alphdiv(DF_alpha = DF_alpha, lm_fitlist = lm_fitlist, measures = alpha_div_measures, group = 
                                             group_var, shape = shape, color_levels = color_levels, test = "t.test")
# --

TrList <- c(alpha_div_boxplots, alpha_div_lmPlots)
TrList <- TrList[order(names(TrList))] # to get the plots in the right order

```

```{r, fig.width = 14, fig.height = (length(TrList)/3)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TrList, ncol = 3))
```

- - p.values comparing alpha diversities between the levels in group_var

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(alpha_div_pVals)
# print(xtable(alpha_div_pVals, align = "|c|c|c|c|c|c|c|c|c|", digits = 5), include.rownames = FALSE)
```

- **Write your conclusion here:** *e.g.: as expected for dada2 pooled = FALSE data, rarifying has little effect on alpha diversity measures*



## Rarefaction curves

- rarefaction curves calculate alpha diversity (richness) for each sample for different total counts in steps from 0 up to the chosen maximal total count value (i.e. rare_max_total, for final value see below plots).
    - samples with total counts < rare_max_total have consequently shorter rarefaction curves, i.e. curves that stop before max_total

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (is.null(rare_max_total)){
        rare_max_total <- quantile(sample_sums(ps), probs = .25)
}

rarefaction_curves <- raref_curve_richness(physeq = ps, group_var = group_var, max_total = rare_max_total, step_size = step_size, color_levels = color_levels, seed = seed)
```

```{r, fig.width = 12, fig.height = 20, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "rarefaction_p.pdf", width = 12, height = 10)
grid.arrange(rarefaction_curves[["Tr_richness_col"]], rarefaction_curves[["Tr_richness_group"]], rarefaction_curves[["Tr_richness_grad"]], ncol = 1)
# dev.off()

```

- The used rare_max_total was `r rare_max_total`
- **Write your conclusion here:** *e.g.: visual proof that dada2 data plateaus super early because of the absence of singletons.*


# Preprocessing (filtering)

- **filtering strategy**:
    - I filter on prevalence (keeping taxa with prevalence > `r prevalence`) and taxa_sums() (keeping taxa whose taxa sums/total counts over all samples are above the `r taxa_sums_quantile` quantile)
        - prevalence filter so that ASVs that are very rare and only in few samples have no effect on the distance measures
        - taxa_sums_quantile filter, so that very abundant ASVs (clearly real species you would think) stay, even if they are only in a few samples. These might well separate these samples
    - because of the taxa_sums_quantile filter, I first do a DeSEQ-like total counts adjustment on the samples *using the size factors that have been calculated above on the ASV phyloseq*. NB: this library size adjustment affects the taxa_sums_quantile filter, it does not affect prevalence nor the subsequent relative abundances. So only analyses using ps_tca are affected, not analyses using ps_filt or ps_filt_ra (relative abundance).
- **NB: to see how the size factors affect the total counts of the different samples, see also the Phylum analysis at the bottom of the document**


```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - filter -
# NB: remember I calculate SFs already above before possible tax_glom, because I think it is better to calculate them on many taxa, i.e. at ASV level,
# because I got some crazy size factors after tax_glom to phylum level, as expectable since median of ratio is used
library_size_adjust_list <- adj_LS(ps, SFs = SFs) 
ps_tca <- library_size_adjust_list[[1]] # library size adjusted because of taxa_sums filter
# SFs <- library_size_adjust_list[[2]]

ps_tca_filt <- phyloseq::filter_taxa(ps_tca, function(x){(sum(x > min_obs) > (prevalence/100)*length(x)) || (sum(x) > quantile(taxa_sums(ps_tca), probs = taxa_sums_quantile/100))}, prune = TRUE)

ps_filt <- phyloseq::prune_taxa(taxa_names(ps_tca_filt), ps) # you need ps_filt for DESeq2Apply_physeq

ps_filt_ra <- phyloseq::transform_sample_counts(ps_filt, function(x){x/sum(x)}) # same for ps_tca_filt
# --

# - Generate a visual overview of the filtering step -
filterList <- plot_abundance_prev_filter(physeq = ps_tca, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)
# --

# - Show the size factors to get an impression whether they are different between your groups -
SFList <- plot_sizeFactors(physeq = ps, SFs = SFs, group_var = group_var, color_levels = color_levels, shape = shape, test = "t.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
# --
```


```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
filterList[[1]]
#dev.off()
```

```{r, fig.width = 10, fig.height = 8, warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "filter2_0prev.pdf", width = 8, height = 8)
filterList[[2]]
# dev.off()
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(filterList[[3]])
# print(xtable(filterList[[3]][,c(1,2,4,6:9)], align = "|c|c|c|c|c|c|c|c|", digits = 1), include.rownames = FALSE)
```

- **`r ntaxa(ps_filt)` out of `r ntaxa(ps)` taxa survived the filter (`r round(100*ntaxa(ps_filt)/ntaxa(ps), 1)` %)**
- **`r sum(otu_table(ps_tca_filt))` out of `r sum(otu_table(ps_tca))` counts survived the filter (`r round(100*sum(otu_table(ps_tca_filt))/sum(otu_table(ps_tca)), 1)` %)** (based on ps_tca vs ps_tca_filt, not ps vs ps_filt)


```{r, fig.width = 14, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "filter_p.pdf", width = 7, height = 6)
grid.arrange(SFList[[2]], SFList[[3]], ncol = 2)
#dev.off()
```


- **Write your conclusion here:** *e.g.: size factors look reasonable, filtering was as expected quite some taxa were filtered out but not a lot of counts. Not sure if some taxa were more affected than others*



# beta-diversity distances and ordination

## Calculate distances, construct ordination plots, test for significance

```{r, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(ps_filt_ra, dist_methods) # produces objects of class "dist"

dist_list2 <- calc_beta_div_distances(ps_tca_filt, dist_methods)
# --

# - Add boxplot of the distance comparisons of the groups plus pairwise t tests -
dist_analysis_list <- compare_beta_div_distances_directly(dist_list = dist_list, physeq = ps_filt_ra, group_var = group_var, test = "t.test", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")),
                               p.adjust.method = "BH")

dist_analysis_list2 <- compare_beta_div_distances_directly(dist_list = dist_list2, physeq = ps_tca_filt, group_var = group_var, test = "t.test", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")),
                               p.adjust.method = "BH")
# --


# - add Permutational Multivariate Analysis of Variance Using Distance Matrix and vegan::adonis -
adonis_list <- lapply(dist_list, function(dist_obj){
        loop_vegan_adonis(dist_obj = dist_obj, group_fac = sample_data(ps_filt_ra)[[group_var]])
})

adonis_list2 <- lapply(dist_list2, function(dist_obj){
        loop_vegan_adonis(dist_obj = dist_obj, group_fac = sample_data(ps_tca_filt)[[group_var]])
})
# --

# - construct ordination plots -
pcoas <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, color_levels = color_levels, ordination_type = "PCoA", group_var = group_var, shape = shape, coord_cor = coord_cor) 

TrList_ra <- vector(mode = "list", length = 2*length(pcoas[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_ra[[counter]] <- pcoas[["ordination_Tr_taxa"]][[i]]
}

pcoas2 <- calc_ordination_from_distances(ps_tca_filt, dist_list = dist_list2, color_levels = color_levels, ordination_type = "PCoA", group_var = group_var, shape = shape, coord_cor = coord_cor) 

TrList_counts <- vector(mode = "list", length = 2*length(pcoas2[["ordination_Tr_samples"]])) 
counter <- 0
for (i in 1:length(pcoas2[["ordination_Tr_samples"]])) {
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_samples"]][[i]]
        counter <- counter + 1
        TrList_counts[[counter]] <- pcoas2[["ordination_Tr_taxa"]][[i]]
}

# nmdss <- calc_ordination_from_distances(ps_filt_ra, dist_list = dist_list, ordination_type = "NMDS", group_var = group_var) 

# nmdss2 <- calc_ordination_from_distances(ps_tca_filt, dist_list = dist_list2, ordination_type = "NMDS", group_var = group_var) 

# --
# plot_list[[4]] <- pcoas[["ordination_Tr_samples"]][[1]]
```



### Beta diversity results for relative abundance (ps_filt_ra)

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p_0prev.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list[["DistanceBoxplots"]], nrow = length(dist_analysis_list[["DistanceBoxplots"]])))
# dev.off()
```


- **Write your conclusion here:** *e.g.: Whenever a group clearly separates from another group, I would expect that the within group distances (blue) are smaller than the between group distances (red). If this is not the case I do not care about significant p-values, as there are simply so many distance comparisons.*


```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(dist_analysis_list[["DistancePValuesDirect"]])){
        print(knitr::kable(dist_analysis_list[["DistancePValuesDirect"]][[i]], caption = names(dist_analysis_list[["DistancePValuesDirect"]])[i]))
}
```


- **Ordination Plots**

```{r, fig.width = 10, fig.height = 3.5*length(TrList_ra), warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "pcoa_ra.pdf", width = 10, height = 8)
do.call("grid.arrange", c(TrList_ra, ncol = 2))
# TrList_ra[[1]]
# dev.off()
```

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```


- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(adonis_list)){
        print(knitr::kable(adonis_list[[i]], caption = names(adonis_list)[i]))
}
```


- **Write your conclusion here:** *Neiter me nor adonis can see obvious clustering of the groups based on beta-diversity distances calculated from relative abundance values*



### Beta diversity results for size adjusted counts (ps_tca_filt)

- **Distance boxplots**

```{r, fig.width = 14, fig.height = 10*length(dist_analysis_list[["DistanceBoxplots"]]), warning = FALSE, message = FALSE, echo = FALSE}
# pdf(file = "beta_p_0prev.pdf", width = 10, height = 8)
do.call("grid.arrange", c(dist_analysis_list2[["DistanceBoxplots"]], nrow = length(dist_analysis_list2[["DistanceBoxplots"]])))
# dev.off()

```

- **Write your conclusion here:** *e.g.: Whenever a group clearly separates from another group, I would expect that the within group distances (blue) are smaller than the between group distances (red). If this is not the case I do not care about significant p-values, as there are simply so many distance comparisons that they tend to be significant.*


```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(dist_analysis_list2[["DistancePValuesDirect"]])){
        print(knitr::kable(dist_analysis_list2[["DistancePValuesDirect"]][[i]], caption = names(dist_analysis_list2[["DistancePValuesDirect"]])[i]))
}
```

- **Ordination Plots**

```{r, fig.width = 10, fig.height = 3.5*length(TrList_ra), warning = FALSE, message = FALSE, echo = FALSE}
#pdf(file = "pcoa_ra.pdf", width = 10, height = 8)
do.call("grid.arrange", c(TrList_counts, ncol = 2))
# TrList_ra[[1]]
# dev.off()
```

```{r, fig.width = 10, fig.height = 12, warning = FALSE, message = FALSE, echo = FALSE}
# do.call("grid.arrange", c(nmdss[["ordination_Tr_own"]], ncol = 2))
```

- **adonis, Permutational Multivariate Analysis of Variance Using Distance Matrix**:

```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(adonis_list2)){
        print(knitr::kable(adonis_list2[[i]], caption = names(adonis_list2)[i]))
}
```


- **Write your conclusion here:** *Neiter me nor adonis can see obvious clustering of the groups based on beta-diversity distances calculated from size factor adjusted counts*



# Differential Abundance analysis

- **For all analyses, fisher, DeSeq, wilcoxon, TbT, even if no taxon was significantly different between the groups (levels), the ten taxa with the lowest p-value (test stat) are illustrated. Also even if more than 25 taxa are significant, only the 25 top hits are illustrated.**
- **NB further: if significance levels are shown with asterisk in the violin plots, these are significant levels coming from a t.test or wilcoxon test (ggpubr stat_compare_mean), the significance levels from the actual test are shown in the tables and indicated in the taxon_names of the violin plots**



## Overview heat map


```{r, warning = FALSE, message = FALSE, echo = FALSE}
overview <- get_overview_of_physeq(ps_tca_filt)

taxNames <- as.character(tax_table(ps_filt_ra)[, taxonomic_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)

Tr <- make_heat_map_physeq(ps_filt_ra, group_var, color_levels = color_levels, max_abundance_for_color = .05, tax_order = NULL,
                                 tax_names = taxNames, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))

# Tr_list <- make_heat_map_physeq_levels(ps_tca_filt, group_var, max_abundance_for_color = NULL, tax_order = NULL,
#                                        tax_names = NULL, color_sample_names = TRUE, gradient_steps = c(0.25, 0.5, 0.75, 1))
```

- some statistics on ps_tca_filt (size adjusted counts phyloseq)

```{r, warning = FALSE, message = FALSE, echo = FALSE}
knitr::kable(overview)
```

- a heat map plot of relative abundances (ps_filt_ra) to visualise sparsity and maybe also abundance differences
- **NB: 0 counts, i.e. where the taxon is absent in a sample,  are shown in red**

```{r, fig.width = 14, fig.height = (1 + 0.07*ntaxa(ps_filt_ra)), warning = FALSE, message = FALSE, echo = FALSE}
Tr
```

- **Write your conclusion here:** *Can you find taxa that are clearly more "red" in one group than the other, i.e. more sparse?*



## Differential prevalence analysis with fisher.test

- **simply a fisher exact test testing whether some taxa are more prevalent in one group than the other**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps_filt_ra 
# --

# - run the test function resulting in result list -
res_list <- test_diffs_in_prevalence(physeq = physeq_to_test, group_var = group_var, p.adj.method = "fdr", minCount = 0L)
# -- 

# - get result tables and inputs for plot functions -
table_and_plotIntput <- prepare_diff_abundance_results_for_plotting(res_list = res_list, physeq = physeq_to_test, taxonomic_level = taxonomic_level)
# -- 

# - generate plots for result visualisation -
heat_maps <- lapply(1:length(res_list), function(i){
        maps <- make_heat_map_physeq_levels(table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, color_levels = color_levels, max_abundance_for_color = .05, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})
# --
```

- the number of significantly different taxa found:

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(table_and_plotIntput[["original_head_values"]], row.names = FALSE)
```

- list the most differently "abundant" taxa for all group_var level combinations (**NB: even if no taxon is significant the 10 with the lowest p_values are shown**)

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(res_list)){
        print(knitr::kable(table_and_plotIntput[["res_table_list"]][[i]], caption = names(res_list)[i]))
}
```

- show heat maps fo the most differently "abundant" taxa for all group_var level combinations (again 10 shown if less are actually significant)

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(table_and_plotIntput[["head_values"]])), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps, ncol = 1))
```

- **Write your conclusion here:** *e.g: Some taxa were indeed only found in one group or the other*



## DeSeq2 analysis

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps_filt 
# --

# - run the test function resulting in result list - NB: a bit special for DESeq because you also get a new physeq
out_list <- DESeq2Apply_physeq(physeq = physeq_to_test, group_var = group_var, SFs = SFs, p.adjust.method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
res_list <- out_list[[1]]
physeq_to_test <- out_list[[2]]
# -- 

# - get result tables and inputs for plot functions -
table_and_plotIntput <- prepare_diff_abundance_results_for_plotting(res_list = res_list, physeq = physeq_to_test, taxonomic_level = taxonomic_level)
# -- 

# - generate plots for result visualisation -
heat_maps <- lapply(1:length(res_list), function(i){
        maps <- make_heat_map_physeq_levels(table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, color_levels = color_levels, max_abundance_for_color = NULL, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots <- lapply(1:length(res_list), function(i){
        plotlist <- plot_toptaxa_boxAndviolin(physeq = table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_levels = color_levels, ttestp = "yes")
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance (with pseudocounts):
violin_plots <- lapply(violin_plots, `[[`, 8)
# --
```

- the number of significantly different taxa found:

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(table_and_plotIntput[["original_head_values"]], row.names = FALSE)
```


- list of the most differently "abundant" taxa for all level combinations

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(res_list)){
        print(knitr::kable(table_and_plotIntput[["res_table_list"]][[i]], caption = names(res_list)[i]))
}
```

- corresponding heat maps of the most differently abundant taxa

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(table_and_plotIntput[["head_values"]])), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps, ncol = 1))
```

- corresponding violin plots of most differentially abundant taxa (nb: asterisks fro t.test)

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(table_and_plotIntput[["head_values"]])/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots, ncol = 1))
```


- **Write your conclusion here:** *e.g: the taxa DESeq finds differ mainly in prevalence, i.e. they are not present at all in one of the other group.*



## Wilcoxon test excluding zeros using relative abundances 

- **NB: done with ps_filt_ra, but could also be done with ps_tca_filt, or maybe log(ps_tca_filt)**


```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps_filt_ra
# --

# - run the test function resulting in result list - NB: a bit special for DESeq because you also get a new physeq
res_list <- wilcoxTestApply_physeq(physeq = physeq_to_test, group_var = group_var, excludeZeros = TRUE, p.adjust.method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
# -- 

# - get result tables and inputs for plot functions -
table_and_plotIntput <- prepare_diff_abundance_results_for_plotting(res_list = res_list, physeq = physeq_to_test, taxonomic_level = taxonomic_level)
# -- 

# - generate plots for result visualisation -
heat_maps <- lapply(1:length(res_list), function(i){
        maps <- make_heat_map_physeq_levels(table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, color_levels = color_levels, max_abundance_for_color = .05, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots <- lapply(1:length(res_list), function(i){
        plotlist <- plot_toptaxa_boxAndviolin(physeq = table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_levels = color_levels, ttestp = "yes")
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance (with pseudocounts):
violin_plots <- lapply(violin_plots, `[[`, 8)
# --

```

- the number of significantly different taxa found:

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(table_and_plotIntput[["original_head_values"]], row.names = FALSE)
```


- list the most differently "abundant" taxa for all level combinations

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(res_list)){
        print(knitr::kable(table_and_plotIntput[["res_table_list"]][[i]], caption = names(res_list)[i]))
}
```

- the corresponding heat maps of the most differentially abundant taxa

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(table_and_plotIntput[["head_values"]])), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps, ncol = 1))
```

- the corresponding heat maps of the most differentially abundant taxa

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(table_and_plotIntput[["head_values"]])/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots, ncol = 1))
```

- **Write your conclusion here:** *e.g.: Since prevalence is not really linked to abundance when present (see low R2 in the plots above), I like to exclude 0s and compare prevalence separately.*



## Taxon by Taxon Matrix analysis

- Remember: Taxon by taxon ratios are independent of sample size adjustment, I anyway use ps_tca_filt here to expemplify the results. Maybe in the future I find a better "count" value fitting to the TbT method.
- **NB: the method lacks currently own p-values, so the names in the heat map and violin plots are always taxonomic_level_namne__, while in for example DeSEQ the last __ are signi. and signi_adj.**

### Based on groupSum ranking

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps_tca_filt # would be the same with ps_filt except for the violin_plots, so TbT method of course independent of SF corrections
# --

# - run the test function resulting in result list - 
TbTmatrixes_list <- calculate_TbTmatrixes(physeq_to_test, group_var = group_var)
# NB: because ratios have been divided by geometric mean over all samples and then log transformed, each row (over all samples) sums to 0:
# max(sapply(TbTmatrixes_list[[1]], function(x){max(apply(x, 1, sum, na.rm = T))}))
res_list <- evaluate_TbTmatrixes(TbTmatrixes_list, physeq = physeq_to_test, group_var = group_var, p.adjust.method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
# --

# - get result tables and inputs for plot functions -
table_and_plotIntput <- prepare_diff_abundance_results_for_plotting(res_list = res_list, physeq = physeq_to_test, taxonomic_level = taxonomic_level, TbT = "yes")
# --

# - generate plots for result visualisation -
heat_maps <- lapply(1:length(res_list), function(i){
        maps <- make_heat_map_physeq_levels(table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, color_levels = color_levels, max_abundance_for_color = NULL, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_sample_names = TRUE, gradient_steps = c(0.15, 0.3, 0.45, 1))
        maps[[i]]
})


violin_plots <- lapply(1:length(res_list), function(i){
        plotlist <- plot_toptaxa_boxAndviolin(physeq = table_and_plotIntput[["pruned_physeqs_to_test"]][[i]], group_var = group_var, tax_order = table_and_plotIntput[["tax_orders"]][[i]], tax_names = table_and_plotIntput[["row_names_for_heat_maps"]][[i]], color_levels = color_levels, ttestp = "yes")
        plotlist[[i]]
})

# there are 8 plots per list, only pick violin plot faceted, and logged abundance (with pseudocounts):
violin_plots <- lapply(violin_plots, `[[`, 8)
# --

```

- the number of significantly different taxa found:
- **NB: always 10 currently because method provides no p-values yet**

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
knitr::kable(table_and_plotIntput[["original_head_values"]], row.names = FALSE)
```


- list the most differently "abundant" taxa for all level combinations

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
for (i in 1:length(res_list)){
        print(knitr::kable(table_and_plotIntput[["res_table_list"]][[i]], caption = names(res_list)[i]))
}
```

- corresponding heat maps

```{r, fig.width = 14, fig.height = (5 + 0.41*sum(table_and_plotIntput[["head_values"]])), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(heat_maps, ncol = 1))
```

- corresponding violin plots

```{r, fig.width = 14, fig.height = 2.3*(ceiling(sum(table_and_plotIntput[["head_values"]])/5)), warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(violin_plots, ncol = 1))
```

- **Write your conclusion here:** *e.g.: it deals with the zeros by basically ignoring them, that gives advantage to more prevalent taxas. I like that.*



# Few analyses at phylum level

- **NB: these are addded independent of the chosen taxonomic_level because they give good overview**

## Abundance barplots of all samples

```{r, warning = FALSE, message = FALSE, echo = FALSE}
if (taxonomic_level != "Phylum"){
        ps <- phyloseq::tax_glom(ps, taxrank = "Phylum", NArm = FALSE)
        
        library_size_adjust_list <- adj_LS(ps, SFs = SFs) 
        ps_tca <- library_size_adjust_list[[1]] # library size adjusted because of taxa_sums filter
        taxonomic_level <- "Phylum"
}

ps_ra <- phyloseq::transform_sample_counts(ps, function(x){x/sum(x)})


# bar_plot_ps <- plot_bar_own(physeq = ps, x = "Sample", y = "Abundance", group_var = group_var, color_levels = color_levels, fill = "Phylum",
#                          color_sample_names = TRUE, facet_grid = NULL)
# 
# bar_plot_ps_tca <- plot_bar_own(physeq = ps_tca, x = "Sample", y = "Abundance", group_var = group_var, color_levels = color_levels, fill = "Phylum",
#                          color_sample_names = TRUE, facet_grid = NULL)

bar_plot_ps_ra <- plot_bar_own(physeq = ps_ra, x = "Sample", y = "Abundance", group_var = group_var, color_levels = color_levels, fill = "Phylum",
                         color_sample_names = TRUE, facet_grid = NULL)


bar_plot_ps_vs_ps_tca <- plot_bar_own_compare(physeq = ps, physeq2 = ps_tca, x = "Sample", y = "Abundance", group_var = group_var, color_levels = color_levels, fill = "Phylum", color_sample_names = TRUE)
```

```{r, fig.width = 14, fig.height = 15, warning = FALSE, message = FALSE, echo = FALSE}
grid.arrange(bar_plot_ps_vs_ps_tca, bar_plot_ps_ra, ncol = 1)
```

- **Write your conclusion here:** *e.g.: You can see the effect of library size adjustment (size factors), which does not affect the relative abundances, some samples might almost lack Bacteroidetes, isn't that weird?*



## Firmicutes to other phyla ratio

- **good to look at because independent of library size adjustment and compositionality**

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps
# --

# - calculate ratio matrixes and assemble taxa names for plots -
raw_TbTmatrixes_list <- calculate_raw_TbTmatrixes(physeq = physeq_to_test, group_var = group_var)
taxNames <- as.character(tax_table(physeq_to_test)[, taxonomic_level])
taxNames[is.na(taxNames)] <- "NA"
taxNames <- sapply(strsplit(taxNames, split = "/"), `[`, 1)
# --

# - plot Firmicutes to all other phyla ratio plots NB: you could change taxa_den to maybe only Bacteroides -
FirmicutesRatios <- plot_taxa_ratios_levelPairs(TbTmatrixes_list = raw_TbTmatrixes_list, physeq = physeq_to_test, group_var = group_var, tax_names = taxNames, taxa_nom = "Firmicutes", taxa_den = NULL, color_levels = color_levels, test = "t.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))


FirmicutesRatioPlotsLevelPairs <- lapply(FirmicutesRatios, `[[`, 5) # I choose violin plots and the logged once, NB boxplots under 3


FirmicutesRatiosAllLevels <- plot_taxa_ratios_AllLevels(physeq = physeq_to_test, group_var = group_var, tax_names = taxNames, taxa_nom = "Firmicutes", taxa_den = NULL, color_levels = color_levels, test = "t.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))


FBRatiosTotalCounts <- plot_sampleSums_FirmtoBac(physeq = physeq_to_test, group_var = group_var, tax_names = taxNames, taxa_nom = "Firmicutes", taxa_den = "Bacteroidetes", color_levels = color_levels, test = "t.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))

# --
```

- just a test if sample_sums might affect the Firmicutes to Bacteroidetes ratio

```{r, fig.width = 8, fig.height = 6, warning = FALSE, message = FALSE, echo = FALSE}
FBRatiosTotalCounts + scale_y_log10()# in this version I plot the boxplot again the logged ones
```


- now the ratio plots and pVals, **NB: currently t.test here!**
- NB: these plots show only taxa for which statistical test (t or wilcoxon) was possible, and only samples for which both taxa were present!
- **NB: the plots show the logged ratios, the analysis was also done on non-logged ratios, see pVals below**

```{r, fig.width = 14, fig.height = length(FirmicutesRatioPlotsLevelPairs)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(FirmicutesRatioPlotsLevelPairs, ncol = 1))
```

```{r, fig.width = 14, fig.height = 10, warning = FALSE, message = FALSE, echo = FALSE}
FirmicutesRatiosAllLevels[[6]] # in this version I plot the boxplot again the logged ones
```

- the p-vals for the ratios

```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(FirmicutesRatios)){
        print(knitr::kable(FirmicutesRatios[[i]][["pVals"]], caption = names(FirmicutesRatios)[i]))
}
```


- the p-vals for the ratios

```{r, warning = FALSE, message = FALSE, echo = FALSE}
for (i in 1:length(FirmicutesRatios)){
        print(knitr::kable(FirmicutesRatios[[i]][["pValsLog"]], caption = names(FirmicutesRatios)[i]))
}
```


- **Write your conclusion here:** *e.g.: The Firmicutes to Actinobacteria ratio seems higher in group 2. NB. this is independent of compositionality or library size adjustment.*


### Taxon vs taxon ratio tile plots 

- Basically performs ratio **wilcoxon test** for *all phyla combinations*. So if you replace t.test with wilcox.test above, you get the results for Firmicutes. 

```{r, warning = FALSE, message = FALSE, echo = FALSE}
# - choose the physeq object to run the test on -
physeq_to_test <- ps
# --


TbT_tiles <- create_raw_TbT_TilePlots(raw_TbTmatrixes_list, physeq = physeq_to_test, group_var = group_var, tax_names = taxNames, test = "wilcoxon", p_adjust = "none")
TbT_tiles_show <- lapply(TbT_tiles, `[[`, 2)
```

**NB: purple (up) means ratio row taxon/column taxon is higher in first group, and vice versa**

```{r, fig.width = 8, fig.height = length(TbT_tiles_show)*5, warning = FALSE, message = FALSE, echo = FALSE}
do.call("grid.arrange", c(TbT_tiles_show, ncol = 1))
```

- **Write your conclusion here:** *e.g.: very few ratios differ. See that the table is symmetrical, it should be.*




