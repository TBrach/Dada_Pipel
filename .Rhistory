names(F_QualityStats) <- SampleNames
names(R_QualityStats) <- SampleNames
message("*********************** Quality Stats Collected ***********************
********************************************************************")
cat("\n*** Quality Stats Collected ***", file = LogFile, append = TRUE)
} else {
if((names(F_QualityStats) != SampleNames) || (names(R_QualityStats) != SampleNames)) {
stop("The given F_QualityStats or R_QualityStats do not fit to the SampleNames in path!")
}
message("*********************** Quality Stats given ***********************
********************************************************************")
cat("\n*** Quality Stats given***", file = LogFile, append = TRUE)
}
DataFolder <- file.path(path2, "Dada_Data")
# ATTENTION: FUNCTION DELETES ALL FILES ALREADY PRESRENT in DataFolder
if(file.exists(DataFolder)){
file.remove(list.files(DataFolder, full.names = TRUE))
}
dir.create(DataFolder, showWarnings = FALSE)
if(!file.exists(DataFolder)){
stop("DataFolder could not be created! something wrong with path2, maybe permission denied.")
}
ptm <- proc.time()
LogFile <- file.path(DataFolder, "DadaWrapper.log")
cat("Time after package installation: ", file = LogFile)
cat(paste(Sys.time(), "\n"), file = LogFile, append = TRUE)
cat("Package Versions: ", file = LogFile, append = TRUE)
cat(paste(PackageVersions$Package, ": ", PackageVersions$Version, "; ", sep= ""), file = LogFile, append = TRUE)
Input <- list(path = path, F_pattern = F_pattern, R_pattern = R_pattern, path2 = path2,
trimLeft = trimLeft, truncLen = truncLen,
maxN = maxN, maxEE = maxEE, truncQ = truncQ,
NSAM.LEARN = NSAM.LEARN, err_F = err_F, err_R = err_R,
minOverlap = minOverlap, maxMismatch = maxMismatch, F_QualityStats = F_QualityStats,
R_QualityStats = R_QualityStats, filtFs = filtFs, filtRs = filtRs)
Input
if (is.null(F_QualityStats) || is.null(R_QualityStats)) {
F_QualityStats <- list()
R_QualityStats <- list()
for (i in seq_along(F_fastq)) {
Current_FWfq <- F_fastq[i]
Current_dfFW <- qa(Current_FWfq, n = 1e06)[["perCycle"]]$quality
# df is a data frame containing for each cycle (nt) the distribution of Quality scores
# e.g. Cycle 1 had 7 different quality scores, then 7 rows of cycle one, for each score the count says how many reads had this score
Current_dfFW <- dplyr::group_by(Current_dfFW, Cycle)
Current_dfQStatsFW <- dplyr::summarise(
Current_dfFW,
NoReads = sum(Count),
Mean_QS = sum(Count*Score)/sum(Count),
SD_QS = sqrt(sum(Count*((Score-Mean_QS)^2))/(NoReads-1)),
Median_QS = Score[which(cumsum(Count)/sum(Count) >= .5)][[1]],
q25_QS = Score[which(cumsum(Count)/sum(Count) >= .25)][[1]],
q75_QS = Score[which(cumsum(Count)/sum(Count) >= .75)][[1]])
# Check that all reads are of same length
x <- range(Current_dfQStatsFW$NoReads)
if (!all.equal(x[1], x[2], tolerance = .Machine$double.eps ^ 0.5)) {
stop("Not all reads of same length in file", F_fastq[i])
}
F_QualityStats[[i]] <- as.data.frame(Current_dfQStatsFW)
# as.data.frame to un-dplyr the data.frame
# collect the same stats for the RV FastQ files
Current_RVfq <- R_fastq[i]
Current_dfRV <- qa(Current_RVfq, n = 1e06)[["perCycle"]]$quality
Current_dfRV <- dplyr::group_by(Current_dfRV, Cycle)
Current_dfQStatsRV <- dplyr::summarise(
Current_dfRV,
NoReads = sum(Count),
Mean_QS = sum(Count*Score)/sum(Count),
SD_QS = sqrt(sum(Count*((Score-Mean_QS)^2))/(NoReads-1)),
Median_QS = Score[which(cumsum(Count)/sum(Count) >= .5)][[1]],
q25_QS = Score[which(cumsum(Count)/sum(Count) >= .25)][[1]],
q75_QS = Score[which(cumsum(Count)/sum(Count) >= .75)][[1]])
## Check that all reads are of same length
x <- range(Current_dfQStatsRV$NoReads)
if (!all.equal(x[1], x[2], tolerance = .Machine$double.eps ^ 0.5)) {
stop("Not all reads of same length in file", R_fastq[i])
}
R_QualityStats[[i]] <- as.data.frame(Current_dfQStatsRV)
rm(Current_FWfq, Current_dfFW, Current_dfQStatsFW,
Current_RVfq, Current_dfRV, Current_dfQStatsRV, x)
}
# add the sample names as names to the lists:
names(F_QualityStats) <- SampleNames
names(R_QualityStats) <- SampleNames
message("*********************** Quality Stats Collected ***********************
********************************************************************")
cat("\n*** Quality Stats Collected ***", file = LogFile, append = TRUE)
} else {
if((names(F_QualityStats) != SampleNames) || (names(R_QualityStats) != SampleNames)) {
stop("The given F_QualityStats or R_QualityStats do not fit to the SampleNames in path!")
}
message("*********************** Quality Stats given ***********************
********************************************************************")
cat("\n*** Quality Stats given***", file = LogFile, append = TRUE)
}
F_QualityStats
FilteredFolder <- file.path(path2, "Dada_FilteredFastqs")
filtFs
if(file.exists(FilteredFolder)){
file.remove(list.files(FilteredFolder, full.names = TRUE))
}
dir.create(FilteredFolder, showWarnings = FALSE)
filtFs <- file.path(FilteredFolder, paste0(SampleNames, "_F_Filtered.fastq.gz"))
filtRs <- file.path(FilteredFolder, paste0(SampleNames, "_R_Filtered.fastq.gz"))
names(filtFs) <- SampleNames
names(filtRs) <- SampleNames
filtFs
?fastqPairedFilter
all(file.exists(filtFs))
file.exists(filtFs)
!all(file.exists(filtFs)) || !all(file.exists(filtRs))
filtFs
filtFs <- NULL
filtRs <- NULL
FilteredFolder <- file.path(path2, "Dada_FilteredFastqs")
if(is.null(filtFs) || is.null(filtRs)){
## Not sure if this is wanted, deleting all files that are already in the DataFolder folder
if(file.exists(FilteredFolder)){
file.remove(list.files(FilteredFolder, full.names = TRUE))
}
dir.create(FilteredFolder, showWarnings = FALSE)
filtFs <- file.path(FilteredFolder, paste0(SampleNames, "_F_Filtered.fastq.gz"))
filtRs <- file.path(FilteredFolder, paste0(SampleNames, "_R_Filtered.fastq.gz"))
names(filtFs) <- SampleNames
names(filtRs) <- SampleNames
for(i in seq_along(F_fastq)) {
message(paste("**Filtering sample No:", i, "called:", SampleNames[i]), " **")
cat(paste("\n**Filtering sample No:", i, "called:", SampleNames[i]), file = LogFile, append = TRUE)
fastqPairedFilter(c(F_fastq[i], R_fastq[i]), c(filtFs[i], filtRs[i]), trimLeft = trimLeft,
truncLen = truncLen, maxN = maxN, maxEE = maxEE, truncQ = truncQ,
compress=TRUE, verbose=TRUE)
}
# check if files have been created
if(!all(file.exists(filtFs)) || !all(file.exists(filtRs))) {
cat("\n*** ERROR: Not all filtered files were created, maybe trimming impossible***", file = LogFile, append = TRUE)
stop("** Not all filtered files were created, maybe trimming impossible")
}
message("*********************** Filtering Done ***********************
********************************************************************")
cat("\n*** Filtering Done ***", file = LogFile, append = TRUE)
} else {
if((names(filtFs) != SampleNames) || (names(filtRs) != SampleNames)) {
cat("\n*** ERROR: The given filtFs or filtRs do not have sample names!***", file = LogFile, append = TRUE)
stop("The given filtFs or filtRs do not have sample names!")
}
if(!all(file.exists(filtFs)) && !all(file.exists(filtRs))) {
cat("\n*** ERROR: Not all files in the given filtFs or filtRs existed***", file = LogFile, append = TRUE)
stop("** Not all files in the given filtFs or filtRs existed")
}
message("*********************** Filtered files were given ***********************
********************************************************************")
cat("\n*** Filtered files were given ***", file = LogFile, append = TRUE)
}
?filterAndTrim
filterAndTrim
prng <- .Random.seed
prng
?learnErrors
learnErrors
str(1:10)
str(list(1:10))
typeof(1:10)
x <- 1:10
attributes(x)
typeof(x)
length(x)
is.list(x)
is.atomic(x)
NA_integer_(2)
NA_integer_()
NA_integer_
swirl()
x1c <- simbias()
apply(x1c, 1, mean)
fit1 <- lm(Fertility ~ Agriculture, swiss)
fit3 <- lm(Fertility ~ Agriculture + Examination + Education, swiss)
anova(fit1, fit3)
deviance(fit3)
d <- deviance(fit3)/df.residual(fit3)
n <- (deviance(fit1)-deviance(fit3))/(df.residual(fit1)-df.residual(fit3))
n/d
pf(n/d, 2, 43, lower.tail=FALSE)
shapiro.test(fit3$residuals)
anova(fit1, fit3, fit5, fit6)
rm(list = ls())
getwd()
path = "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/DanFunD"
F_pattern = "1.fq.gz"
R_pattern = "2.fq.gz"
path2 = NULL
trimLeft = c(10,10)
truncLen = c(220, 160)
maxEE = 1
maxN = 0
truncQ = 2
NSAM.LEARN = 40
err_F = NULL
err_R = NULL
minOverlap = 20
maxMismatch = 0
F_QualityStats = NULL
R_QualityStats = NULL
filtFs = NULL
filtRs = NULL
?.Random.seed
.Random.seed
head(.Random.seed)
seed(1)
set.seed(1)
head(.Random.seed)
swirl()
ravenData
mdl <- glm(ravenWinNum ~ ravenScore, family = "binomial", ravenData)
lodds <- predict(mdl, data.frame(ravenScore=c(0, 3, 6)))
exp(lodds)/(1+exp(lodds))
summary(mdl)
exp(confint(mdl))
anova(mdl)
qchisq(0.95, 1)
swirl()
var(rpois(1000, 50))
nxt()
head(hits)
class(hits[,'date'])
as.integer(head(hits[,'date']))
mdl <- glm(visits ~ date, poisson, hits)
summary(mdl)
exp(confint(mdl, 'date'))
which.max(hits[,'visits'])
hits[704,]
lambda <- mdl$fitted.values[704]
qpois(.95, lambda)
mdl2 <- glm(visits ~ date, offset = log(visits + 1), family = poisson, hits)
mdl2 <- glm(formula = simplystats ~ date, family = poisson, data =hits, offset = log(visits + 1))
qpois(.95, mdl2$fitted.values[704])
rm(list = ls())
getwd()
path = "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/DanFunD"
F_pattern = "1.fq.gz"
R_pattern = "2.fq.gz"
path2 = NULL
trimLeft = c(10,10)
truncLen = c(220, 160)
maxEE = 1
maxN = 0
truncQ = 2
NSAM.LEARN = 40
err_F = NULL
err_R = NULL
minOverlap = 20
maxMismatch = 0
_QualityStats = NULL
F_QualityStats = NULL
R_QualityStats = NULL
filtFs = NULL
filtRs = NULL
try(library(dada2), biocLite("dada2"))
## Short Read
try(library(ShortRead), biocLite("ShortRead"))
## ggplot2
try(library(ggplot2), install.packages("ggplot2"))
## dplyr
try(library(dplyr), install.packages("dplyr"))
## dplyr
try(library(tidyr), install.packages("tidyr"))
PackageVersions <- data.frame(Package = c("dada2", "ShortRead", "ggplot2", "dplyr", "tidyr"),
Version = c(packageVersion("dada2"),
packageVersion("ShortRead"),
packageVersion("ggplot2"),
packageVersion("dplyr"),
packageVersion("tidyr")))
message(paste(PackageVersions$Package, ": ", PackageVersions$Version, "; ", sep= ""))
if(is.null(path2)){
path2 = path
}
folders <- list.dirs(path, recursive = FALSE, full.names = FALSE)
folders
if(length(folders) != 0) {
SampleNames <- folders
if(sum(grepl("^Dada", SampleNames)) != 0){
warning("**There are folders starting with \"Dada\" in your path folder, maybe you have run the function on this path folder before\n.
The folders starting with Dada will not be considered sample folders!!\n Files within Dada_Data Dada_FilteredFastqs and Dada_Plots will be overwritten**")
}
# exclude Folders starting with "Dada" from the folders considered as sample fodlers
if(length(grep("^Dada", SampleNames))!=0) {
SampleNames <- SampleNames[-grep("^Dada", SampleNames)]
}
F_fastq <- character(length = length(SampleNames))
R_fastq <- character(length = length(SampleNames))
for (i in 1:length(SampleNames)) {
CurrentPath <- file.path(path, SampleNames[i])
if(sum(grepl(F_pattern, list.files(CurrentPath))) == 0) {
stop(paste("F_pattern fits no file in ", CurrentPath))
}
if(sum(grepl(F_pattern, list.files(CurrentPath))) > 1) {
stop(paste("F_pattern fits several files in ", CurrentPath))
}
if(sum(grepl(R_pattern, list.files(CurrentPath))) == 0) {
stop(paste("R_pattern fits no file in ", CurrentPath))
}
if(sum(grepl(R_pattern, list.files(CurrentPath))) > 1) {
stop(paste("R_pattern fits several files in ", CurrentPath))
}
F_fastq[i] <- file.path(CurrentPath, list.files(CurrentPath)[grepl(F_pattern, list.files(CurrentPath))])
R_fastq[i] <- file.path(CurrentPath, list.files(CurrentPath)[grepl(R_pattern, list.files(CurrentPath))])
}
} else {
stop("No sample folders were found in the given path! Currently the Dada2_wrap function can only handle the situation where the fastq files are in separate folders for each sample.
These folders have to be in the \"path\" folder. Other situations have to be added.")
}
F_fastq
DataFolder <- file.path(path2, "Dada_Data")
# ATTENTION: FUNCTION DELETES ALL FILES ALREADY PRESRENT in DataFolder
if(file.exists(DataFolder)){
file.remove(list.files(DataFolder, full.names = TRUE))
}
dir.create(DataFolder, showWarnings = FALSE)
if(!file.exists(DataFolder)){
stop("DataFolder could not be created! something wrong with path2, maybe permission denied.")
}
ptm <- proc.time()
LogFile <- file.path(DataFolder, "DadaWrapper.log")
cat("Time after package installation: ", file = LogFile)
cat(paste(Sys.time(), "\n"), file = LogFile, append = TRUE)
cat("Package Versions: ", file = LogFile, append = TRUE)
cat(paste(PackageVersions$Package, ": ", PackageVersions$Version, "; ", sep= ""), file = LogFile, append = TRUE)
if (is.null(F_QualityStats) || is.null(R_QualityStats)) {
F_QualityStats <- list()
R_QualityStats <- list()
for (i in seq_along(F_fastq)) {
Current_FWfq <- F_fastq[i]
Current_dfFW <- qa(Current_FWfq, n = 1e06)[["perCycle"]]$quality
# df is a data frame containing for each cycle (nt) the distribution of Quality scores
# e.g. Cycle 1 had 7 different quality scores, then 7 rows of cycle one, for each score the count says how many reads had this score
Current_dfFW <- dplyr::group_by(Current_dfFW, Cycle)
Current_dfQStatsFW <- dplyr::summarise(
Current_dfFW,
NoReads = sum(Count),
Mean_QS = sum(Count*Score)/sum(Count),
SD_QS = sqrt(sum(Count*((Score-Mean_QS)^2))/(NoReads-1)),
Median_QS = Score[which(cumsum(Count)/sum(Count) >= .5)][[1]],
q25_QS = Score[which(cumsum(Count)/sum(Count) >= .25)][[1]],
q75_QS = Score[which(cumsum(Count)/sum(Count) >= .75)][[1]])
# Check that all reads are of same length
x <- range(Current_dfQStatsFW$NoReads)
if (!all.equal(x[1], x[2], tolerance = .Machine$double.eps ^ 0.5)) {
stop("Not all reads of same length in file", F_fastq[i])
}
F_QualityStats[[i]] <- as.data.frame(Current_dfQStatsFW)
# as.data.frame to un-dplyr the data.frame
# collect the same stats for the RV FastQ files
Current_RVfq <- R_fastq[i]
Current_dfRV <- qa(Current_RVfq, n = 1e06)[["perCycle"]]$quality
Current_dfRV <- dplyr::group_by(Current_dfRV, Cycle)
Current_dfQStatsRV <- dplyr::summarise(
Current_dfRV,
NoReads = sum(Count),
Mean_QS = sum(Count*Score)/sum(Count),
SD_QS = sqrt(sum(Count*((Score-Mean_QS)^2))/(NoReads-1)),
Median_QS = Score[which(cumsum(Count)/sum(Count) >= .5)][[1]],
q25_QS = Score[which(cumsum(Count)/sum(Count) >= .25)][[1]],
q75_QS = Score[which(cumsum(Count)/sum(Count) >= .75)][[1]])
## Check that all reads are of same length
x <- range(Current_dfQStatsRV$NoReads)
if (!all.equal(x[1], x[2], tolerance = .Machine$double.eps ^ 0.5)) {
stop("Not all reads of same length in file", R_fastq[i])
}
R_QualityStats[[i]] <- as.data.frame(Current_dfQStatsRV)
rm(Current_FWfq, Current_dfFW, Current_dfQStatsFW,
Current_RVfq, Current_dfRV, Current_dfQStatsRV, x)
}
# add the sample names as names to the lists:
names(F_QualityStats) <- SampleNames
names(R_QualityStats) <- SampleNames
message("*********************** Quality Stats Collected ***********************
********************************************************************")
cat("\n*** Quality Stats Collected ***", file = LogFile, append = TRUE)
} else {
if((names(F_QualityStats) != SampleNames) || (names(R_QualityStats) != SampleNames)) {
stop("The given F_QualityStats or R_QualityStats do not fit to the SampleNames in path!")
}
message("*********************** Quality Stats given ***********************
********************************************************************")
cat("\n*** Quality Stats given***", file = LogFile, append = TRUE)
}
F_QualityStats
save(PackageVersions, F_QualityStats, R_QualityStats, Input, file = file.path(DataFolder, "QualityStats.RData"))
TimePassed <- proc.time()-ptm
cat("\nTime after Quality Stats collection: ", file = LogFile, append = TRUE)
cat(paste(Sys.time(), "\n"), file = LogFile, append = TRUE)
cat(paste("Time Passed in total: ", TimePassed[3]), file = LogFile, append = TRUE)
cat("\n*** Start generating Quality Plots ***", file = LogFile, append = TRUE)
##############################
### Generate and save some quality plots
##############################
PlotFolder <- file.path(path2, "Dada_Plots")
# ATTENTION: FUNCTION DELETES ALL FILES ALREADY PRESRENT in PlotFolder
if(file.exists(PlotFolder)){
file.remove(list.files(PlotFolder, full.names = TRUE))
}
dir.create(PlotFolder, showWarnings = FALSE)
FilteredFolder <- file.path(path2, "Dada_FilteredFastqs")
if(is.null(filtFs) || is.null(filtRs)){
## Not sure if this is wanted, deleting all files that are already in the DataFolder folder
if(file.exists(FilteredFolder)){
file.remove(list.files(FilteredFolder, full.names = TRUE))
}
dir.create(FilteredFolder, showWarnings = FALSE)
filtFs <- file.path(FilteredFolder, paste0(SampleNames, "_F_Filtered.fastq.gz"))
filtRs <- file.path(FilteredFolder, paste0(SampleNames, "_R_Filtered.fastq.gz"))
names(filtFs) <- SampleNames
names(filtRs) <- SampleNames
for(i in seq_along(F_fastq)) {
message(paste("**Filtering sample No:", i, "called:", SampleNames[i]), " **")
cat(paste("\n**Filtering sample No:", i, "called:", SampleNames[i]), file = LogFile, append = TRUE)
fastqPairedFilter(c(F_fastq[i], R_fastq[i]), c(filtFs[i], filtRs[i]), trimLeft = trimLeft,
truncLen = truncLen, maxN = maxN, maxEE = maxEE, truncQ = truncQ,
compress=TRUE, verbose=TRUE)
}
# check if files have been created
if(!all(file.exists(filtFs)) || !all(file.exists(filtRs))) {
cat("\n*** ERROR: Not all filtered files were created, maybe trimming impossible***", file = LogFile, append = TRUE)
stop("** Not all filtered files were created, maybe trimming impossible")
}
message("*********************** Filtering Done ***********************
********************************************************************")
cat("\n*** Filtering Done ***", file = LogFile, append = TRUE)
} else {
if((names(filtFs) != SampleNames) || (names(filtRs) != SampleNames)) {
cat("\n*** ERROR: The given filtFs or filtRs do not have sample names!***", file = LogFile, append = TRUE)
stop("The given filtFs or filtRs do not have sample names!")
}
if(!all(file.exists(filtFs)) || !all(file.exists(filtRs))) {
cat("\n*** ERROR: Not all files in the given filtFs or filtRs existed***", file = LogFile, append = TRUE)
stop("** Not all files in the given filtFs or filtRs existed")
}
message("*********************** Filtered files were given ***********************
********************************************************************")
cat("\n*** Filtered files were given ***", file = LogFile, append = TRUE)
}
save(PackageVersions, F_QualityStats, R_QualityStats, filtFs, filtRs, Input, file = file.path(DataFolder, "QualityStats.RData"))
cat("\nTime after filtering step: ", file = LogFile, append = TRUE)
cat(paste(Sys.time(), "\n"), file = LogFile, append = TRUE)
TimePassed <- proc.time()-ptm
cat(paste("Time Passed in total: ", TimePassed[3]), file = LogFile, append = TRUE)
cat("\n*** Start estimating err_F if not given ***", file = LogFile, append = TRUE)
fastqPairedFilter
learnErrors
is.integer(NSAM.LEARN)
is.double(NSAM.LEARN)
nreads = 1e+06
SamplesFor_errF
is.null(err_F)
if(is.null(NSAM.LEARN)){
NSAM.LEARN <- length(SampleNames)
message("Your NSAM.LEARN was \"NULL\" all samples are used for err_F estimation")
} else if(!is.numeric(NSAM.LEARN)){
NSAM.LEARN <- length(SampleNames)
message("Your NSAM.LEARN was not numeric, therefore all samples are used for err_F estimation")
} else if(NSAM.LEARN >= length(SampleNames)){
NSAM.LEARN <- length(SampleNames)
message("Your NSAM.LEARN covered all samples, i.e. all samples are used for err_F estimation")
}
NSAM.LEARN
if(NSAM.LEARN == length(SampleNames)){
SamplesFor_errF <- filtFs
} else {
prng <- .Random.seed
SamplesFor_errF <- sample(filtFs, NSAM.LEARN)
attr(SamplesFor_errF, "seed") <- prng
}
SamplesFor_errF
?learnErrors
fls <- sample(fls)
fls <- SamplesFor_errF
drps <- vector("list", length(fls))
drps
fls
i in seq_along(fls)
seq_along(fls)
?is.list.of
dada2:::is.list.of
!is.list(fls)
fls
class(fls)
is.list(fls)
is(fls, "character")
i = 1
drps
drps[[i]] <- derepFastq(fls[[i]])
drps[[1]]
dd <- drps[[1]]
dd
dd$uniques
6*5/2
dd
?derepFastq
typeof(dd$uniques)
sum(dd$uniques)
typeof(dd$quals)
mat <- dd$quals
View(mat)
dim(mat)
dd$map
drpsa <- derepFastq(fls)
drpsa
dd
class(drpsa)
?learnErrors
fls
drpsa
dds <- dada(drpsa, err = NULL, selfConsist = TRUE, multithread = multithread)
dds <- dada(drpsa, err = NULL, selfConsist = TRUE, multithread = TRUE)
