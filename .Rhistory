iMDS  <- ordinate(GPhfsf, "MDS", distance=iDist) #
iMDSPCoA  <- ordinate(GPhfsf, "PCoA", distance=iDist) #
iMDSNMDS  <- ordinate(GPhfsf, "NMDS", distance=iDist)
data(enterotype)
enterotype
enterotype <- subset_species(enterotype, Genus != "-1")
data(enterotype)
enterotype <- subset_taxa(enterotype, Genus != "-1")
enterotype
as(otu_table(enterotype), "data.frame")
as.data.frame(otu_table(enterotype))
ET <- as.data.frame(otu_table(enterotype))
range(ET)
rm(list = ls())
data(GlobalPatterns)
GP <- GlobalPatterns
ntaxa(GP) # 19216
sample_data(GP)$human = factor( get_variable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue") )
GPh <- subset_samples(GP, subset = human == TRUE )
GPhf <- filter_taxa(GPh, function(x){sum(x != 0) > .3*length(x)}, prune = TRUE) # still 3670 taxa
total = median(sample_sums(GPhf))
standf = function(x, t=total) round(t * (x / sum(x)))
GPhfs = transform_sample_counts(GPhf, standf)
range(sample_sums(GPhfs))
GPhfs = transform_sample_counts(GPhfs, function(x){x/sum(x)})
GPhfs
GPhfsf = filter_taxa(GPhfs, function(x) sd(x)/mean(x) > 3.0, prune = TRUE) # down to 383 taxa
GPhfsf
sample_sums(GPhfsf) # again very different but I think fine since all have now same taxa
plot_bar(GPhfsf, x = "Sample", y = "Abundance", fill = "SampleType")
plot_bar(GPhfsf, x = "SampleType", y = "Abundance", fill = "Phylum")
theme_set(theme_bw())
dist_methods <- unlist(distanceMethodList)
# I reduce
dist_methods <- dist_methods[c(1,2, 5:8)]
plist <- vector("list", length(dist_methods))
names(plist) = dist_methods
plistPCoA <- vector("list", length(dist_methods))
names(plistPCoA) = dist_methods
plistNMDS <- vector("list", length(dist_methods))
names(plistNMDS) = dist_methods
for( i in dist_methods ){
# Calculate distance matrix
iDist <- distance(GPhfsf, method=i)
## NB her: as(iDist, "matrix") # is a nsamplesxnsamples matrix
# Calculate ordination
iMDS  <- ordinate(GPhfsf, "MDS", distance=iDist) #
iMDSPCoA  <- ordinate(GPhfsf, "PCoA", distance=iDist) #
iMDSNMDS  <- ordinate(GPhfsf, "NMDS", distance=iDist)
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p <- NULL
# Create plot, store as temp variable, p
p <- plot_ordination(GPhfsf, iMDS, color="SampleType")
# Add title to each plot
p <- p + ggtitle(paste("MDS using distance method ", i, sep=""))
# Save the graphic to file.
plist[[i]] = p
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p1 <- NULL
# Create plot, store as temp variable, p
p1 <- plot_ordination(GPhfsf, iMDSPCoA, color="SampleType")
# Add title to each plot
p1 <- p1 + ggtitle(paste("PCoA using distance method ", i, sep=""))
# Save the graphic to file.
plistPCoA[[i]] = p1
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p2 <- NULL
# Create plot, store as temp variable, p
p2 <- plot_ordination(GPhfsf, iMDSNMDS, color="SampleType")
# Add title to each plot
p2 <- p2 + ggtitle(paste("NMDS using distance method ", i, sep=""))
# Save the graphic to file.
plistNMDS[[i]] = p2
}
plist[[1]]
plist[[3]]
plist[[4]]
plist[[5]]
plist[[6]]
plist
library(gridExtra)
grid.arrange(plist, nrow = 3)
?grid.arrange
grid.arrange(unlist(plist), nrow = 3)
do.call("grid.arrange", c(plist, nrow=3))
?do.call
grid.arrange(c(plist[[1]], plist[[2]]), nrow = 1)
grid.arrange(c(plist[1], plist[2]), nrow = 1)
grid.arrange(plist[[1]], nrow = 1)
grid.arrange(plist[[1]], plist[[2]], nrow = 1)
df = ldply(plist, function(x) x$data)
grid.arrange(plist[[1]], plist[[2]], plist[[3]], plist[[4]], plist[[5]], plist[[6]],nrow = 3)
library(plyr)
df = ldply(plist, function(x) x$data)
View(df)
plist[[1]]$data
rbind(plist[[1:6]]$data)
names(plist)
plist[[1]]$data
View(df)
names(df)[1] <- "distance"
p = ggplot(df, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p = p + facet_wrap(~distance, scales="free")
p
do.call("grid.arrange", c(plist, nrow=3))
names(df)[1] <- "distance"
p = ggplot(df, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p = p + facet_wrap(~distance, scales="free")
p
plist[[1]]$labels
do.call("grid.arrange", c(plist, nrow=3))
do.call("grid.arrange", c(plistPCoA, nrow=3))
do.call("grid.arrange", c(plistNMDS, nrow=3))
do.call("grid.arrange", c(plistPCoA, plistNMDS, nrow=2*length(plistPCoA)))
data(enterotype)
2*length(plistPCoA)
do.call("grid.arrange", c(plistPCoA, plistNMDS, nrow=length(plistPCoA)))
do.call("grid.arrange", c(plistPCoA, plistNMDS, nrow=2))
df = ldply(plistPCoA, function(x) x$data)
df1 = ldply(plistNMDS, function(x) x$data)
df$Method <- PCoA
df$Method <- "PCoA"
df1$Method <- "NMDS"
dfC <- rbind(df, df1)
names(df)
names(df1)
names(df1)[2,3] <- names(df)[2,3]
names(df1)[2:3] <- names(df)[2:3]
dfC <- rbind(df, df1)
p = ggplot(dfC, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p = p + facet_wrap(method~distance, scales="free")
p
p = ggplot(dfC, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p = p + facet_wrap(Method~distance, scales="free")
p
p = ggplot(dfC, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p
p = p + facet_wrap(~distance, scales="free")
p
df = ldply(plistPCoA, function(x) x$data)
df1 = ldply(plistNMDS, function(x) x$data)
df$Method <- "PCoA"
df1$Method <- "NMDS"
names(df1)[2:3] <- names(df)[2:3]
names(df)[1] <- "distance"
names(df1)[1] <- "distance"
dfC <- rbind(df, df1)
p = ggplot(dfC, aes(x = Axis.1, y = Axis.2, color=SampleType))
p = p + geom_point(size=3, alpha=0.5)
p = p + facet_wrap(Method~distance, scales="free")
p
dist_methods <- unlist(distanceMethodList)
dist_methods
rm(list = ls())
distanceMethodList
# Only sample-wise distances are currently supported (the type argument), but eventually OTU-wise (e.g. species) distances will be supported as well.
?phyloseq::distance
## example physeq
data(GlobalPatterns)
GP <- GlobalPatterns
ntaxa(GP) # 19216
## Filtering the GP to reduce processing time
# keep only human samples
sample_data(GP)$human = factor( get_variable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue") )
GPh <- subset_samples(GP, subset = human == TRUE )
## keep only taxa present in at least 30% of samples
GPhf <- filter_taxa(GPh, function(x){sum(x != 0) > .3*length(x)}, prune = TRUE) # still 3670 taxa
## do their normalisation
total = median(sample_sums(GPhf))
standf = function(x, t=total) round(t * (x / sum(x)))
GPhfs = transform_sample_counts(GPhf, standf)
range(sample_sums(GPhfs))
## change to relative abundance here
GPhfs = transform_sample_counts(GPhfs, function(x){x/sum(x)})
## keep only taxa with good variation
GPhfsf = filter_taxa(GPhfs, function(x) sd(x)/mean(x) > 3.0, prune = TRUE) # down to 388 taxa
sample_sums(GPhfsf) # again very different but I think fine since all have now same taxa
plot_bar(GPhfsf, x = "Sample", y = "Abundance", fill = "SampleType")
plot_bar(GPhfsf, x = "SampleType", y = "Abundance", fill = "Phylum")
theme_set(theme_bw())
##### I now do their enterotypes example but for this Global Pattern set
# NB: I ran into trouble figuring out that many of these distances appear to need relative abundances!
# therefore I added the relative abundance above
dist_methods <- unlist(distanceMethodList)
# I reduce
dist_methods <- dist_methods[dist_methods %in% c("unifrac", "wunifrac", "jsd", "canberra", "bray", "jaccard")]
# NB: UniFrac requires a tree! GP has a tree
## I save plots using MDS/PCoA (test if difference) and NMDS!
plist <- vector("list", length(dist_methods))
names(plist) = dist_methods
plistPCoA <- vector("list", length(dist_methods))
names(plistPCoA) = dist_methods # NB: CAN BE LEFT OUT SAME AS MDS!!
plistNMDS <- vector("list", length(dist_methods))
names(plistNMDS) = dist_methods
for( i in dist_methods ){
# Calculate distance matrix
iDist <- distance(GPhfsf, method=i)
## NB her: as(iDist, "matrix") # is a nsamplesxnsamples matrix
# Calculate ordination
iMDS  <- ordinate(GPhfsf, "MDS", distance=iDist) #
iMDSPCoA  <- ordinate(GPhfsf, "PCoA", distance=iDist) #
iMDSNMDS  <- ordinate(GPhfsf, "NMDS", distance=iDist)
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p <- NULL
# Create plot, store as temp variable, p
p <- plot_ordination(GPhfsf, iMDS, color="SampleType")
# Add title to each plot
p <- p + ggtitle(paste("MDS using distance method ", i, sep=""))
# Save the graphic to file.
plist[[i]] = p
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p1 <- NULL
# Create plot, store as temp variable, p
p1 <- plot_ordination(GPhfsf, iMDSPCoA, color="SampleType")
# Add title to each plot
p1 <- p1 + ggtitle(paste("PCoA using distance method ", i, sep=""))
# Save the graphic to file.
plistPCoA[[i]] = p1
## Make plot
# Don't carry over previous plot (if error, p will be blank)
p2 <- NULL
# Create plot, store as temp variable, p
p2 <- plot_ordination(GPhfsf, iMDSNMDS, color="SampleType")
# Add title to each plot
p2 <- p2 + ggtitle(paste("NMDS using distance method ", i, sep=""))
# Save the graphic to file.
plistNMDS[[i]] = p2
}
do.call("grid.arrange", c(plist, nrow=3))
rm(list = ls())
data(GlobalPatterns)
GP <- GlobalPatterns
# ntaxa(GP) # 19216
## Filtering the GP to reduce processing time
# keep only human samples
sample_data(GP)$human = factor( get_variable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue") )
GPh <- subset_samples(GP, subset = human == TRUE )
## keep only taxa present in at least 30% of samples
GPhf <- filter_taxa(GPh, function(x){sum(x != 0) > .3*length(x)}, prune = TRUE) # still 3670 taxa
## do their normalisation
total = median(sample_sums(GPhf))
standf = function(x, t=total) round(t * (x / sum(x)))
GPhfs = transform_sample_counts(GPhf, standf)
#range(sample_sums(GPhfs))
## change to relative abundance here
GPhfs = transform_sample_counts(GPhfs, function(x){x/sum(x)})
## keep only taxa with good variation
GPhfsf = filter_taxa(GPhfs, function(x) sd(x)/mean(x) > 3.0, prune = TRUE) # down to 388 taxa
sample_sums(GPhfsf)
plot_bar(GPhfsf, x = "Sample", y = "Abundance", fill = "SampleType")
plot_bar(GPhfsf, x = "SampleType", y = "Abundance", fill = "Phylum")
dist_methods <- unlist(distanceMethodList)
dist_methods <- dist_methods[dist_methods %in% c("unifrac", "wunifrac", "jsd", "canberra", "bray", "jaccard", "euclidean")]
dist methods
dist_methods
Distlist <- vector("list", length(dist_methods))
names(Distlist) = dist_methods
for( i in dist_methods ){
# Calculate distance matrix
iDist <- phyloseq::distance(GPhfsf, method=i)
Distlist[[i]] = iDist
}
phyloseq::distance
showMethods("distance")
phyloseq::standardGeneric
search()
?vegdist
vegdist
vegan::vegdist
Dislist[["Euclidean"]]
Dislist[["euclidean"]]
Distlist$euclidean
DistEucl <- vegan::vegdist(GPhfsf, method = 'euclidean')
DistEucl <- vegan::vegdist(as(otu_table(GPhfsf, "matrix"), method = 'euclidean')
q
DistEucl <- vegan::vegdist(as(otu_table(GPhfsf, "matrix")), method = 'euclidean')
as(otu_table(GPhfsf, "matrix"))
GPhfsf
otu_table(GPhfsf)
?as
DistEucl <- vegan::vegdist(as(otu_table(GPhfsf), "matrix"), method = 'euclidean')
DistEucl
DistEucl <- vegan::vegdist(t(as(otu_table(GPhfsf), "matrix")), method = 'euclidean')
DistEucl
identical(DistEucl, Distlist$euclidean)
DistEucl
Distlist$euclidean
all.equal(DistEucl, Distlist$euclidean)
?identical
identical(DistEucl, Distlist$euclidean, ignore.environment = TRUE)
identical(DistEucl, Distlist$euclidean, ignore.environment = TRUE, attriab.as.set = FALSE)
attr(DistEucl)
?attr
?attributes
attributes(DistEucl)
?all.equal
identical(as(DistEucl, "matrix"), as(Distlist$euclidean, "matrix)", ignore.environment = TRUE)
)
identical(as(DistEucl, "matrix"), as(Distlist$euclidean, "matrix"))
vegan::vegdist
?pmatch
method = "euclidean"
method
ZAP <- 1e-15
if (!is.na(pmatch(method, "euclidian")))
method <- "euclidean"
x <- t(as(otu_table(GPhfsf), "matrix"))
x
METHODS <- c("manhattan", "euclidean", "canberra", "bray",
"kulczynski", "gower", "morisita", "horn", "mountford",
"jaccard", "raup", "binomial", "chao", "altGower", "cao",
"mahalanobis")
method <- pmatch(method, METHODS)
method
inm <- METHODS[method]
inm
if (!method %in% c(1, 2, 6, 16) && any(rowSums(x, na.rm = TRUE) ==
0))
warning("you have empty rows: their dissimilarities may be meaningless in method ",
dQuote(inm))
if (!method %in% c(1, 2, 6, 16) && any(x < 0, na.rm = TRUE))
warning("results may be meaningless because data have negative entries in method ",
dQuote(inm))
if (method == 11 && any(colSums(x) == 0))
warning("data have empty species which influence the results in method ",
dQuote(inm))
if (method == 6)
x <- decostand(x, "range", 2, na.rm = TRUE, ...)
if (method == 16)
x <- veganMahatrans(scale(x, scale = FALSE))
if (binary)
x <- decostand(x, "pa")
N <- nrow(x <- as.matrix(x))
N
if (method %in% c(7, 13, 15) && !identical(all.equal(as.integer(x),
as.vector(x)), TRUE))
warning("results may be meaningless with non-integer data in method ",
dQuote(inm))
d <- .C("veg_distance", x = as.double(x), nr = N, nc = ncol(x),
d = double(N * (N - 1)/2), diag = as.integer(FALSE),
method = as.integer(method), NAOK = na.rm, PACKAGE = "vegan")$d
na.rm = FALSE
?.C
binary = FALSE
diag = FALSE
upper = FALSE
d <- .C("veg_distance", x = as.double(x), nr = N, nc = ncol(x),
d = double(N * (N - 1)/2), diag = as.integer(FALSE),
method = as.integer(method), NAOK = na.rm, PACKAGE = "vegan")$d
d
if (method == 10)
d <- 2 * d/(1 + d)
d[d < ZAP] <- 0
d
as.double(x)
x
?vegan::vegdist
physeq <- GPhfsf
DF <- as.data.frame(otu_table(physeq))
View(DF)
taxa_are_rows(physeq)
DF <- as.data.frame(t(otu_table(physeq)))
physeq <- GPhfsf
if(taxa_are_rows(physeq)){
DF <- as.data.frame(otu_table(physeq))
} else {
DF <- as.data.frame(t(otu_table(physeq)))
}
physeq <- GPhfsf
if(taxa_are_rows(physeq)){
DF <- as(otu_table(physeq), "matrix")
} else {
DF <- as(t(otu_table(physeq)), "matrix")
}
View(DF)
library(data.table)
data.DT <- setkey(data.table(c(DF), colId = rep(1:ncol(DF), each = nrow(DF)), rowId = rep(1:nrow(DF), times = ncol(DF))), colId)
View(data.DT)
diff.DT <- data.DT[
, {
ccl <- unique(colId)
vv <- V1
data.DT[colId > ccl, .(col2 = colId, V1 - vv)]
}
, keyby = .(col1 = colId)
]
View(diff.DT)
physeq <- GPhfsf
if(taxa_are_rows(physeq)){
DF <- as.data.frame(otu_table(physeq))
} else {
DF <- as.data.frame(t(otu_table(physeq)))
}
DistEucl
dim(DistEucl)
length(DistEucl)
12*12
12*12/2
DistEucl
DistEucl[1]
DistEucl[1,1]
DistEucl[1]
names(DistEucl[1])
attr(DistEucl[1])
attributes(DistEucl[1])
colnames(DF)
colnames(DF)[1:2]
Dist12 <- sqrt(sum(DF[,1]-DF[,2])^2)
Dist12
DF[,1]
Dist12 <- sqrt(sum((DF[,1]-DF[,2])^2))
Dist12
identical(Dist12, DistEucl[1])
Dist12
DistEucl[1]
all.equal(Dist12, DistEucl[1])
View(data.DT)
physeq <- GPhfsf
if(taxa_are_rows(physeq)){
DF <- as(otu_table(physeq), "matrix")
} else {
DF <- as(t(otu_table(physeq)), "matrix")
}
dim(DF)
apply(DF, 2, function(x) x-DF[,1])
dim(apply(DF, 2, function(x) x-DF[,1]))
apply(DF, 2, function(x) (x-DF[,1])^2)
apply(DF, 2, function(x) colSums((x-DF[,1])^2))
sapply(DF, 2, function(x){colSums((x-DF[,1])^2)})
sapply(DF, function(x){colSums((x-DF[,1])^2)})
sapply(DF, function(x){sum((x-DF[,1])^2)})
apply(DF, 2, function(x){sum(x-DF[,1])^2)})
apply(DF, 2, function(x){sum((x-DF[,1])^2)})
apply(DF, 2, function(x){sqrt(sum((x-DF[,1])^2))})
sapply(DF, function(x){sqrt(sum((x-DF[,1])^2))})
sapply(1:ncol(DF), function(y){apply(DF, 2, function(x){sqrt(sum((x-DF[,y])^2))}})
sapply(1:ncol(DF), function(y){apply(DF, 2, function(x){sqrt(sum((x-DF[,y])^2))})})
EuclDistMatrix <- sapply(1:ncol(DF), function(y){apply(DF, 2, function(x){sqrt(sum((x-DF[,y])^2))})})
as(DistEucl, "matrix")
colnames(EuclDistMatrix) <- rownames(EuclDistMatrix)
DistEuclM <- as(DistEucl, "matrix")
DistEuclM
EuclDistMatrix
identical(DistEuclM, EuclDistMatrix)
all.equal(DistEuclM, EuclDistMatrix)
data.DT <- setkey(data.table(c(DF), colId = rep(1:ncol(DF), each = nrow(DF)), rowId = rep(1:nrow(DF), times = ncol(DF))), colId)
View(data.DT)
unique(colId)
unique(data.DT$colId)
View(diff.DT)
data.DT <- setkey(data.table(c(DF), colId = rep(1:ncol(DF), each = nrow(DF)), rowId = rep(1:nrow(DF), times = ncol(DF))), colId)
diff.DT <- data.DT[
, {
ccl <- unique(colId)
vv <- V1
data.DT[colId > ccl, .(col2 = colId, V1 - vv)]
}
, keyby = .(col1 = colId)
]
colnames(data.DT)
colnames(diff.DT)
head(data.DT$colID)
data.DT$colID
View(data.DT)
data.DT[,2]
diff.DT[,2]
diff.DT[,1]
View(data.DT)
colnames(diff.DT)
diff.DT <- data.DT[
, {
ccl <- unique(colId)
vv <- V1
data.DT[colId > ccl, .(col2 = colId, sum(V1 - vv))]
}
, keyby = .(col1 = colId)
]
View(diff.DT)
diff.DT <- data.DT[
, {
ccl <- unique(colId)
vv <- V1
data.DT[colId > ccl, .(col2 = colId, sum((V1 - vv)^2))]
}
, keyby = .(col1 = colId)
]
View(diff.DT)
diff.DT <- data.DT[
, {
ccl <- unique(colId)
vv <- V1
data.DT[colId > ccl, .(col2 = colId, sqrt(sum((V1 - vv)^2)))]
}
, keyby = .(col1 = colId)
]
View(diff.DT)
DistBray <- vegan::vegdist(t(as(otu_table(GPhfsf), "matrix")), method = 'bray')
identical(as(DistBray, "matrix"), as(Distlist$bray, "matrix"))
BrayDistMatrix <- sapply(1:ncol(DF), function(y){apply(DF, 2, function(x){ sum(abs(x-DF[,y]))/sum(x + DF[,y]) })})
colnames(BrayDistMatrix) <- rownames(BrayDistMatrix)
DistBrayM <- as(DistBray, "matrix")
all.equal(DistBrayM, BrayDistMatrix) # TRUE
