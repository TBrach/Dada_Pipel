RS1 <- merge(ReadSummary, samdf, by = "Sample")
Tr <- ggplot(RS1, aes(x = Group, y = FilteredReads, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$FilteredReads, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueAmpliconsWOBimera, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueAmpliconsWOBimera, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = Unique_Amplicons, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$Unique_Amplicons, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueSequences_F, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueSequences_F, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueSequences_R, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueSequences_R, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = DenoisedSequences_F, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$DenoisedSequences_F, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = DenoisedSequences_R, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$DenoisedSequences_R, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
RS1$RemovedSVs <- RS1$Unique_Amplicons - RS1$UniqueAmpliconsWOBimera
Tr <- ggplot(RS1, aes(x = Group, y = RemovedSVs, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$RemovedSVs, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
library(phyloseq); packageVersion("phyloseq")
library(dada2); packageVersion("dada2")
library(vegan); packageVersion("vegan")
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyr); packageVersion("tidyr")
library(gridExtra); packageVersion("gridExtra")
library(xtable); packageVersion("xtable")
PackageVersions <- data.frame(R = version$version.string,
dada2 = packageVersion("dada2"),
vegan = packageVersion("vegan"),
ggplot2 = packageVersion("ggplot2"),
dplyr = packageVersion("dplyr"),
tidyr = packageVersion("tidyr"),
gridExtra = packageVersion("gridExtra"),
xtable = packageVersion("xtable"))
for (i in 1:ncol(PackageVersions)){PackageVersions[,i] <- as.character(PackageVersions[,i])}
PackageVersionsAnal <- tidyr::gather(PackageVersions, key = Package, value = Version)
# ---- Set input arguments including file paths ----
# - filtering inputs -
prevalence <- 20 # in percent
min_obs <- 0L # a taxon will be considered present (for prevalence) if count > min_obs
taxa_sums_quantile <- 90 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence
# --
# - rarefaction inputs -
seed <- 1234
step_size <- 200 # for rarefaction curves
rare_level <- NULL # IF NULL, min(sample_sums(ps)) is used!
rare_type <- "sample" # must be either "sample" or "vegan"
rare_max_total <- NULL # maximal total amplicons value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# --
# - plot/statistics inputs -
taxa_are_rows = FALSE
group_var <- "Group" # tha variable based on which samples will be grouped
group_var_levels <- c("Young", "MiddleAged", "Old") # the factor levels of the group_var in the order you want them in your plots (set to NULL if you do not care)
alpha_div_measures <- c("Observed", "Shannon")
# --
# - beta diversity -
dist_methods <- c("bray", "unifrac", "wunifrac") # otions: see unlist(distanceMethodList)
# --
# - file/path inputs -
datapath <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/16S_Sequencing/2017-07-13_DK_age_ManiAging/Dada2_Analysis_Pooled_Porus"
# NB: taxonomy, tree, and sample path should start in datapath (otherwise change code below)
taxonomy.path <- "Dada_Taxonomy/Silva_v128/Taxonomy.RData"
tree.path <- "Dada_phylogenetic_tree/phylog_tree.rds"
sample.path <- "sample_data/samdf.rds"
functionpath <- "/Users/jvb740/MarieCurie_Work/BackgroundKnowledge/16S_Learning/Dada_Pipel/Functions/"
# --
# ----
# -- Load all data in --
# laod seqtab.nochim
load(file.path(datapath, "Dada_Data/DenoisedData.RData"))
# load QualityStats
load(file.path(datapath, "Dada_Data/QualityStats.RData"))
# load Taxonomy
load(file.path(datapath, taxonomy.path))
# load tree
tree_list <- readRDS(file.path(datapath, tree.path))
# load samdf
samdf <- readRDS(file.path(datapath, sample.path))
if (!is.null(group_var) && !is.null(group_var_levels)){
samdf[[group_var]] <- factor(samdf[[group_var]], levels = group_var_levels, ordered = TRUE)
}
# sanity checks if sample names fit
sample.names <- rownames(seqtab.nochim)
if (!all.equal(sample.names, names(F_QualityStats))) {
stop("check sample names")
}
if (!all.equal(sample.names, as.character(ReadSummary$Sample))) {
stop("check sample names")
}
# # check the size of the objects
# all_objects <- ls()
# object_memory <- vector(mode = "character", length = length(all_objects))
# for (i in 1:length(all_objects)) {
#         object_memory[i] <- object.size(get(all_objects[i]))
# }
# data.frame(all_objects, object_memory)
# ----
# -- load all functions in --
source(file.path(functionpath, "Dada_TaxonomyFunctions.R"))
source(file.path(functionpath, "Dada_PlotFunctions.R"))
# ----
# -- generate phyloseq object --
# Generate the phyloseq file
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows = taxa_are_rows),
sample_data(samdf),
tax_table(taxa.species),
phy_tree(tree_list[["fitGTR"]]$tree))
ps
if (!identical(sample_names(ps), sample.names)) {
stop("check sample names")
}
# ----
samdf <- sample_data(ps)
samdf <- as(samdf, "data.frame")
samdf$Sample <- rownames(samdf)
RS1 <- merge(ReadSummary, samdf, by = "Sample")
Tr <- ggplot(RS1, aes(x = Group, y = FilteredReads, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$FilteredReads, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueAmpliconsWOBimera, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueAmpliconsWOBimera, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = Unique_Amplicons, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$Unique_Amplicons, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueSequences_F, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueSequences_F, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = UniqueSequences_R, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$UniqueSequences_R, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = DenoisedSequences_F, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$DenoisedSequences_F, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
Tr <- ggplot(RS1, aes(x = Group, y = DenoisedSequences_R, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
pairwise.t.test(x = RS1$DenoisedSequences_R, g = RS1[[group_var]], alternative = "two", p.adjust.method = "none", var.equal = F, pool.sd = F)
RS1$RemovedSVs <- RS1$Unique_Amplicons - RS1$UniqueAmpliconsWOBimera
Tr <- ggplot(RS1, aes(x = Group, y = RemovedSVs, col = Group))
Tr <- Tr + geom_boxplot() +
geom_jitter()
Tr
rm(list = ls())
library(tidyr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(gridExtra)
# library(viridis)
library(RColorBrewer)
path <- "/Users/jvb740/MarieCurie_Work/MouseProject/ResultsAndProtocols/ManiAging_Results/Results_RAnalysis"
load(file.path(path, "ManiAging.RData"))
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7")
calc_radius <- function(no2, rad1 = 75, no1 = 18) {
#rad1^2/rad2^2 = no1/no2
rad2 <- sqrt((rad1^2)*no2/no1)
rad2
}
ManiAging[[8]]
names(ManiAging)
ManiAging[["Birthdates_Invoice_Cor"]]
ManiAging[["Birthdates_Invoice_Cor"]]["young"]
middleAged_Birthdate <- ManiAging[["Birthdates_Invoice_Cor"]]["middleAged"]
young_Birthdate <-ManiAging[["Birthdates_Invoice_Cor"]]["young"]
old_Birthdate <- ManiAging[["Birthdates_Invoice_Cor"]]["old"]
as.period(interval(old_Birthdate, now()))
as.period(interval(young_Birthdate, now()))
as.period(interval(middleAged_Birthdate, now()))
?as.period
as.period(interval(old_Birthdate, now()), unit = "month")
as.period(interval(young_Birthdate, now()), unit = "month")
as.period(interval(middleAged_Birthdate, now()), unit = "month")
MRI <- ManiAging[["MRI"]]
MRI <- MRI[MRI$Group %in% c("Young", "Old"),]
LW <- c("Old", "Young")
MRI$Group <- as.factor(MRI$Group)
for (i in 1:length(levels(MRI$Group))){
MRI$Group <- relevel(MRI$Group, ref = LW[i])
}
MRIl <- gather(MRI, key = Type, value = Weight, -Mouse_ID, -Group, -Time)
MRIl$Group <- as.factor(MRIl$Group)
LW <- c("Old", "Young")
for (i in 1:length(levels(MRIl$Group))){
MRIl$Group <- relevel(MRIl$Group, ref = LW[i])
}
MRIl$Type <- as.factor(MRIl$Type)
LW <- c("Fat", "Lean", "Weight")
for (i in 1:length(levels(MRIl$Type))){
MRIl$Type <- relevel(MRIl$Type, ref = LW[i])
}
Tr <- ggplot(MRIl, aes(x = Group, y = Weight, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = "black") +
geom_jitter(width = .2) +
facet_wrap("Type") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1]))+
theme_bw(12) +
ylab("Weight (g)") +
xlab("") +
theme(legend.position = "none")
Tr
Hematology <- ManiAging[["Hematology"]]
View(Hematology)
colnames(Hematology)[4:24] <- c("Leukocytes", "Erythrocytes", "Hemoglobin", "Hematocrit", "MCV", "MCHC", "Thrombocytes", "MPV", "MPC",
"PC_Neutrophils", "PC_Lymphocytes", "PC_Monocytes", "PC_Eosinophils", "PC_Basophils", "PC_LUC", "Neutrophils",
"Lymphocytes", "Monocytes", "Eosinophils", "Basophils", "LUC")
View(Hematology)
Hematology <- mutate(Hematology, Myeloid = Neutrophils + Monocytes + Eosinophils + Basophils + LUC, LymphoidToMyeloid = Lymphocytes/Myeloid)
Hematology <- select(Hematology, 1:10,19:20, 25, 27)
View(Hematology)
Hematologyl <- gather(Hematology, key = Measure, value = Value, -Mouse_ID, -Group, -Date, -Comment)
LW <- c("Old", "Young")
Hematologyl$Group <- as.factor(Hematologyl$Group)
for (i in 1:length(levels(Hematologyl$Group))){
Hematologyl$Group <- relevel(Hematologyl$Group, ref = LW[i])
}
Hematologyl <- gather(Hematology, key = Measure, value = Value, -Mouse_ID, -Group, -Date, -Comment)
str(Hematologyl)
Hematologyl$Group <- factor(Hematologyl$Group, levels = c("Old", "Young"), ordered = TRUE)
Hematologyl <- group_by(Hematologyl, Measure)
str(Hematologyl)
Hematologyl$Measure <- factor(Hematologyl$Measure, levels = c("Leukocytes", "Erythrocytes", "Thrombocytes", "Lymphocytes", "Neutrophils", "Hemoglobin", "Hematocrit",
"MCV", "MCHC", "LymphoidToMyeloid"), ordered = TRUE)
pValues <- summarise(Hematologyl, pValue = t.test(Value ~ Group)$p.value)
pValues
Tr <- ggplot(Hematologyl, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = "black") +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
Tr
pValues <- pValues[match(rev(LW), pValues$Measure),]
pValues
Hematologyl <- group_by(Hematologyl, Measure)
# adjust leveling of measures to order you like
LW <- c("Leukocytes", "Erythrocytes", "Thrombocytes", "Lymphocytes", "Neutrophils", "Hemoglobin", "Hematocrit", "MCV", "MCHC", "LymphoidToMyeloid")
Hematologyl$Measure <- factor(Hematologyl$Measure, levels = LW, ordered = TRUE)
pValues <- summarise(Hematologyl, pValue = t.test(Value ~ Group)$p.value)
Hematologyl <- merge(Hematologyl, pValues, by = "Measure")
Tr <- ggplot(Hematologyl, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = "black") +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
# order pValues like the plot
pValues <- pValues[match(rev(LW), pValues$Measure),]
pValues
Hematologyl <- gather(Hematology, key = Measure, value = Value, -Mouse_ID, -Group, -Date, -Comment)
Hematologyl$Group <- factor(Hematologyl$Group, levels = c("Young", "Old"), ordered = TRUE)
Hematologyl <- group_by(Hematologyl, Measure)
# adjust leveling of measures to order you like
LW <- c("Leukocytes", "Erythrocytes", "Thrombocytes", "Lymphocytes", "Neutrophils", "Hemoglobin", "Hematocrit", "MCV", "MCHC", "LymphoidToMyeloid")
Hematologyl$Measure <- factor(Hematologyl$Measure, levels = LW, ordered = TRUE)
pValues <- summarise(Hematologyl, pValue = t.test(Value ~ Group)$p.value)
Hematologyl <- merge(Hematologyl, pValues, by = "Measure")
Tr <- ggplot(Hematologyl, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = "black") +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
# order pValues like the plot
pValues <- pValues[match(LW, pValues$Measure),]
pValues
geom_boxplot
?geom_boxplot
Hematologyl <- gather(Hematology, key = Measure, value = Value, -Mouse_ID, -Group, -Date, -Comment)
Hematologyl$Group <- factor(Hematologyl$Group, levels = c("Young", "Old"), ordered = TRUE)
Hematologyl <- group_by(Hematologyl, Measure)
# adjust leveling of measures to order you like
LW <- c("Leukocytes", "Erythrocytes", "Thrombocytes", "Lymphocytes", "Neutrophils", "Hemoglobin", "Hematocrit", "MCV", "MCHC", "LymphoidToMyeloid")
Hematologyl$Measure <- factor(Hematologyl$Measure, levels = LW, ordered = TRUE)
pValues <- summarise(Hematologyl, pValue = t.test(Value ~ Group)$p.value)
Hematologyl <- merge(Hematologyl, pValues, by = "Measure")
Tr <- ggplot(Hematologyl, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = "black", outlier.size = NA) +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
# order pValues like the plot
pValues <- pValues[match(LW, pValues$Measure),]
pValues
Tr
Tr <- ggplot(Hematologyl, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = NA, outlier.size = NA) +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
Tr
str(Hematologyl)
Hemato_Claus <- Hematologyl[Hematologyl$Measure %in% c("Hemoglobin", "Neutrophils", "LymphoidToMyeloid")]
Hemato_Claus <- Hematologyl[Hematologyl$Measure %in% c("Hemoglobin", "Neutrophils", "LymphoidToMyeloid"),]
Hemato_Claus
Heamto_Claus$Measure
Hemato_Claus$Measure
Tr <- ggplot(Hemato_Claus, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = NA, outlier.size = NA) +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none")
Tr
Hematology <- ManiAging[["Hematology"]]
View(Hematology)
names(Hematology)
Tr <- Tr + ylab("Neutro in 10^9/L; Hemogl. in mmol/L")
Tr
getwd()
pdf("Hematology_YoungVsOld_Mice.pdf", width = 7, height = 5)
Tr
dev.off()
Tr <- ggplot(Hemato_Claus, aes(x = Group, y = Value, col = Group))
Tr <- Tr +
geom_boxplot(outlier.color = NA, outlier.size = NA) +
geom_jitter(width = 0.2) +
facet_wrap("Measure", scales = "free_y") +
scale_color_manual("", values = c(cbPalette[2], cbPalette[1])) +
theme_bw() +
ylab("") +
xlab("") +
theme(legend.position = "none") +
ylab("Neutrophils in 10^9/L; Hemoglobin in mmol/L")
pdf("Hematology_YoungVsOld_Mice.pdf", width = 7, height = 4.5)
Tr
dev.off()
rm(list = ls())
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/Calendar/app_Calendar.R')
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/Calendar/app_Calendar.R')
rm(list = ls())
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/170506_Calendar/app_Calendar.R')
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
rv <- list()
rv$DFk <- readRDS("/Users/jvb740/Downloads/Faelles.rds")
path <- "/Users/jvb740/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/170506_Calendar"
file <- "calendarFunctions.R"
source(file.path(path,file))
DFkPlot <- rv$DFk
plotDate <- "2017-07-27"
plotDate <- lubridate::parse_date_time(plotDate, orders = "ymd", tz = "CET")
# reduce to all entries that fall into the plotMonth which is a lubridate interval
# NB: because the week could go over the month, you have to add a week of the
# next and the previous months
plotMonth <- interval(start = update(plotDate, day = 1) - weeks(1), end = update(plotDate, day = 1) + months(1) + weeks(1))
DFkPlot <- DFkPlot[int_overlaps(interval(start = DFkPlot$startTime, end = DFkPlot$endTime), plotMonth),]
# ----
rm(list = ls())
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
rv <- list()
rv$DFk <- readRDS("/Users/jvb740/Downloads/Faelles.rds")
path <- "/Users/jvb740/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/170506_Calendar"
file <- "calendarFunctions.R"
source(file.path(path,file))
DFkPlot <- rv$DFk
plotDate <- "2017-07-27"
plotDate <- lubridate::parse_date_time(plotDate, orders = "ymd", tz = "CET")
plotMonth <- interval(start = update(plotDate, day = 1) - weeks(1), end = update(plotDate, day = 1) + months(1) + weeks(1))
DFkPlot <- DFkPlot[int_overlaps(interval(start = DFkPlot$startTime, end = DFkPlot$endTime), plotMonth),]
View(DFkPlot)
DFkPlot$startDate <- format(DFkPlot$startTime, "%Y-%m-%d")
# DFkPlot$startDate <- date(DFkPlot$startTime) #changes tz to UTC therefore
DFkPlot$startDate <- lubridate::parse_date_time(DFkPlot$startDate, orders = "ymd", tz = "CET")
# DFkPlot$endDate <- date(DFkPlot$endTime)
DFkPlot$endDate <- format(DFkPlot$endTime, "%Y-%m-%d")
DFkPlot$endDate <- lubridate::parse_date_time(DFkPlot$endDate, orders = "ymd", tz = "CET")
if(any(DFkPlot$endDate > DFkPlot$startDate)){
DFkPlot <- splitMultidayEntries(DFkPlot)
}
View(DFkPlot)
rm(list = ls())
rm(list = ls())
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
rv <- list()
rv$DFk <- readRDS("/Users/jvb740/Downloads/Faelles.rds")
path <- "/Users/jvb740/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/170506_Calendar"
file <- "calendarFunctions.R"
source(file.path(path,file))
DFkPlot <- rv$DFk
View(DFkPlot)
str(DFkPlot)
tz(DFkPlot$startTime)
tz(DFkPlot$endTime)
plotDate <- "2017-07-27"
plotDate <- lubridate::parse_date_time(plotDate, orders = "ymd", tz = "CET")
plotDate
plotMonth <- interval(start = update(plotDate, day = 1) - weeks(1), end = update(plotDate, day = 1) + months(1) + weeks(1))
plotMonth
View(DFkPlot)
DFkPlot <- DFkPlot[int_overlaps(interval(start = DFkPlot$startTime, end = DFkPlot$endTime), plotMonth),]
View(DFkPlot)
View(DFkPlot)
update(DFkPlot$startTime, hour = 0, minute = 0)
update(DFkPlot$startTime, hour = 0, minute = 0) > update(DFkPlot$endTime, hour = 0, minute = 0)
any(update(DFkPlot$endTime, hour = 0, minute = 0) > update(DFkPlot$startTime, hour = 0, minute = 0))
PlotDF <- DFkPlot
Indexes <- which(update(PlotDF$endTime, hour = 0, minute = 0) > update(PlotDF$startTime, hour = 0, minute = 0))
Indexes
i = 7
multiDayEntry <- PlotDF[i,]
multiDayEntry
rm(list = ls())
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
rv <- list()
rv$DFk <- readRDS("/Users/jvb740/Downloads/Faelles.rds")
path <- "/Users/jvb740/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/170506_Calendar"
file <- "calendarFunctions.R"
source(file.path(path,file))
DFkPlot <- rv$DFk
# -- use plotDate to restrict DFkPlot to entries that overlap with the month of the plotDate plus 1 week on each side --
plotDate <- "2017-07-27"
plotDate <- lubridate::parse_date_time(plotDate, orders = "ymd", tz = "CET")
# reduce to all entries that fall into the plotMonth which is a lubridate interval
# NB: because the week could go over the month, you have to add a week of the
# next and the previous months
plotMonth <- interval(start = update(plotDate, day = 1) - weeks(1), end = update(plotDate, day = 1) + months(1) + weeks(1))
DFkPlot <- DFkPlot[int_overlaps(interval(start = DFkPlot$startTime, end = DFkPlot$endTime), plotMonth),]
View(DFkPlot)
DFkPlot$startDate <- format(DFkPlot$startTime, "%Y-%m-%d")
View(DFkPlot)
DFkPlot$startDate <- lubridate::parse_date_time(DFkPlot$startDate, orders = "ymd", tz = "CET")
DFkPlot$endDate <- format(DFkPlot$endTime, "%Y-%m-%d")
DFkPlot$endDate <- lubridate::parse_date_time(DFkPlot$endDate, orders = "ymd", tz = "CET")
View(DFkPlot)
PlotDF <- DFkPlot
Indexes <- which(update(PlotDF$endTime, hour = 0, minute = 0) > update(PlotDF$startTime, hour = 0, minute = 0))
Inexes
Indexes
i = 7
multiDayEntry <- PlotDF[i,]
multiDayEntry
Dates <- seq(ymd(multiDayEntry$startDate, tz = "CET"), ymd(multiDayEntry$endDate, tz = "CET"), by = 'days')
Dates
DF <- multiDayEntry[rep(1, length(Dates)),]
DF
DF$startDate <- Dates
DF$endDate[1:(nrow(DF)-1)] <- Dates[1:(nrow(DF)-1)]+days(1)
search()
remove.packages("chron")
install.packages(lubridate)
install.packages("lubridate")
install.packages("lubridate")
library(lubridate)
search
search()
